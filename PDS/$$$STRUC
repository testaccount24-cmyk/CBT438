./ ADD NAME=$$$#DATE 0100-02105-02105-2142-00012-00012-00000-SHIPDAT
REGULAR CBT TAPE - VERSION 445    FILE:  550

    ORIGINAL DSNAME:  SBGOLOB.CBT445.FILE550
    ---------------
                    --RECFM-LRECL-BLKSIZE-DSORG
                      FB    80    5600    PO

   PDS117I 34 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,796 RECORDS


TIME THIS PDS WAS SHIPPED:   04/15/02    21:42:23    GMT-5:00

./ ADD NAME=$$NOTE$$ 0101-01342-02046-1209-00008-00005-00000-SBGOLOB

   These macros are a subset of Dan Snyder's macro collection,
   which can be considered the "structured macros".  These macros
   accomplish IF-THEN-ELSE and DO loop logic, in assembler programs.

   Dan Snyder's "more complete" macro collection is on File 438
   of the CBT Tape collection.

./ ADD NAME=$$NOTE$1 0101-02058-02058-1340-00032-00036-00000-GENTR02
Subject: structured macros
Date: Mon, 18 Feb 2002 15:31:49 -0500
From: "Snyder, Dan" <Dan_Snyder@stercomm.com>
To: "Sam Golob (E-mail)" <sbgolob@attglobal.net>

When I was in the process of making this macro package work, I
needed a way to combine OR clauses together and them have them
relate as a group to an AND.  In COBOL a programmer can do it by
nesting clauses within pairs of parentheses, so that's what I did
with this package.

The first character of a conditional phrase must be a '(',
indicating the presence of subparameters.  If the second
character is another '(', then that implies the possibility of
nested conditions.  The IF macro then splits the one or more
conditional phrases contained within the double parentheses into
individual parameters which are then passed to a recursive call
of the IF macro itself.  If you code:

        IF      ((((((((CLC,FIELDA,FIELDB,E)))))))),THENDO

then IF will call itself recursively 7 times (note the macro
level expressed in the line number field):

          IF    ((((((((CLC,FIELDA,FIELDB,E)))))))),THENDO
+         CLC   FIELDA,FIELDB       TWO OPERANDS - SET CONDITION CODE  08-000115
+         JNE   $MDF0013            B AROUND IF-GROUP IF FALSE         01-000198
            MVC   FIELDA,FIELDC
          ENDIF ,
+$MDF0013 DC    0H'0'               DEFINE END OF DO-GROUP             03-000330

Cool, isn't it?
./ ADD NAME=$$READ$$ 0100-01331-01331-1329-00098-00098-00000-GENTR02
                               STRUCTURED MACROS

  THESE MACROS CAN HELP YOU CREATE NEW PROGRAMS AND MODIFY EXISTING CODE BY
  SUPPORTING IF-THEN-ELSE LOGIC WHILE REQUIRING ONLY A SMALL LEARNING CURVE
  FROM WHAT YOU ALREADY KNOW ABOUT S/390 ASSEMBLER (ASSUMING THAT YOU DO
  KNOW IT ALREADY).  EACH 'IF' STATEMENT CAN BE ARBITRARILY COMPLEX, AND THE
  'IF' STATEMENTS CAN BE NESTED AS MANY LEVELS AS YOU MIGHT NEED (CERTAINLY,
  NO ONE WOULD NEED MORE THAN 255 LEVELS OF NESTING, WOULD SHE?).

  EACH GROUP OF INSTRUCTIONS THAT YOU WANT CONDITIONALLY EXECUTED WOULD BE
  HEADED BY AN 'IF' MACRO, AND TERMINATED BY AN 'ENDIF' MACRO.

  IN ITS SIMPLIST FORM, THE OPERAND OF THE 'IF' MACRO CONSISTS OF AN OP-CODE,
  THE FIRST OPERAND ADDRESS, THE SECOND OPERAND ADDRESS, AND A CONDITION. THESE
  FOUR VALUES MUST BE ENCLOSED WITHIN PARENTHESES, AND FOLLOWING THE OPERANDS
  MUST BE A COMMA AND THE STATEMENT TERMINATING TERM 'THENDO'.

  THE OP-CODE MAY BE ANY VALID S/390 OP-CODE THAT SETS THE CONDITION CODE. THE
  FIRST AND SECOND OPERANDS MAY BE ANY VALUES THAT ARE VALID FOR THE INSTRUCTION
  BEING CREATED. THE CONDITION, SUCH AS 'E' OR 'NO, IS ANY VALUE THAT CAN BE
  USED IN CREATING AN EXTENDED MNEMONIC BRANCH INSTRUCTION (SUCH AS 'BE' OR
  'BNO').

  IF YOU CHOOSE 'E' AS THE CONDITION, THEN THE GROUP OF INSTRUCTIONS BETWEEN THE
  'IF' AND THE 'ENDIF' WILL BE EXECUTED ONLY IF THE CONDITION CODE SET BY THE
  OP-CODE AND OPERANDS SPECIFIED IS A ZERO.

  IN THE FOLLOWING EXAMPLES, THE HEADING WILL INDICATE THE
  CONDITIONS IN WHICH THE DO-GROUP WILL BE EXECUTED. IN EACH CASE,
  AN 'IF' STATEMENT DETERMINES THE CONDITIONS, AND AN 'ENDIF'
  STATEMENT TERMINATES THE DO-GROUP. COMMENTS EITHER IN THE HEADING
  OR ON THE APPROPRIATE INSTRUCTIONS WILL INDICATE THE DETAILS.
       HERE IS AN EXAMPLE:

         IF    (CLC,A,B,NE),THENDO

  THE INSTRUCTIONS BETWEEN THIS 'IF' AND ITS MATCHING 'ENDIF' WILL BE EXECUTED
  IF THE RESULT OF THE 'CLC' IS A 1 OR 2 (THE NOT-EQUAL CONDITION).

       TO EXECUTE THE DO-GROUP IF EITHER ONE OF TWO CONDITIONS IS
  TRUE, THE FORMAT IS:

       IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO

       ALTERNATE FORMAT:
                                                            72
       IF    (CLC,A,B,NE),OR,                                C
             (CLC,C,D,NE),THENDO

       SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING
  EXAMPLE, THE DO-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR
  IF BOTH THE SECOND AND THIRD ARE TRUE:

       IF    (CLC,A,B,E),OR,                                 C
             (CLC,C,D,E),AND,                                C
             (CLC,E,F,E),THENDO

       IF THE DO-GROUP IS TO BE PERFORMED IF THE THIRD IS TRUE AND
  EITHER THE FIRST OR SECOND IS TRUE, INCLUDE THE TESTS CONNECTED
  BY THE 'OR' WITHIN ADDITIONAL PARENTHESES:

             * <-NESTING PARENTHESES -> *
       IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C
             (CLC,E,F,E),THENDO

       ALTERNATE FORMAT:
                                                            72
       IF    ((CLC,A,B,E),OR,                                C
             (CLC,C,D,E)),AND,                               C
             (CLC,E,F,E),THENDO

       GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED
  TO DEFINE THE LOGIC DESIRED.
       EACH DO-GROUP MUST BE TERMINATED WITH AN 'ENDIF' STATEMENT
  OR AN 'ELSE' - 'ENDELSE' COMBINATION:

       ENDIF ,
                   - OR -
       ELSE  ,
       ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS
       ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')

       ALTERNATIVELY, A DO-GROUP CAN BE TERMINATED AS FOLLOWS:

       ELSEIF  (CLC,G,H,E),THENDO ...

       ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL
       'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY
       ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE
       GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.

       IF    (...),THENDO            REQUIRED
       ...
       ELSEIF (...),THENDO           OPTIONAL (REPEATED AS REQUIRED)
       ...
       ELSE  ,                       OPTIONAL
       ...
       ENDIF ,                       REQUIRED (OR 'ENDELSE')
./ ADD NAME=$MENDDO1
         MACRO
&NAME    $MENDDO1 &DOGROUP=
         COPY  $MGBLDEF
         LCLA  &J
&$MDGERR SETA  0                   ASSUME NO ERROR
&J       SETA  &$MDGLVL
         AIF   (&J GT 0).OK02
         MNOTE 8,'NO ACTIVE DO-GROUP TO TERMINATE'
         MNOTE 0,' - MACRO GENERATION ABORTED'
&$MDGERR SETA  4                   WARN OTHERS
         MEXIT
.OK02    AIF   ('&DOGROUP' EQ '').SKIP15
         AIF   ('&DOGROUP' NE '*ALL*').TEST10 FALL THROUGH IF *ALL*
&J       SETA  1                   END ALL BUT OUTERMOST DO-GROUP
         AGO   .SKIP20             ENTER COMMON LOOP
.TEST10  AIF   ('&DOGROUP' EQ '&$MDGNAM(&J)').SKIP20
&J       SETA  &J-1
         AIF   (&J GE 1).TEST10
         MNOTE 8,'ATTEMPT TO END NON-EXISTANT DO-GROUP ''&DOGROUP'''
         MNOTE 0,'ALL ACTIVE DO-GROUPS TERMINATED'
&J       SETA  1
         AGO   .SKIP20
.SKIP15  AIF   ('&NAME' EQ '').ENDIT DO NOTHING IF ONLY 1 LEVEL
&NAME    DC    0H'0'               WELL, MAYBE A TAG...
         MEXIT
.SKIP20  AIF   ('&NAME' EQ '').LOOP30
&NAME    DC    0H'0'               DEFINE END OF DO-GROUP
.LOOP30  AIF   (&J GE &$MDGLVL).ENDIT END 1 BEFORE LAST LEVEL
         $MENDDO2                  END 1 LEVEL
         AIF   (&$MDGERR NE 0).ENDIT QUIT IF ERROR OCCURRED
         AIF   (&$MDGLVL LE 1).ENDIT
         AGO   .LOOP30
.ENDIT   MEND
./ ADD NAME=$MENDDO2 0104-01331-02017-1452-00023-00022-00000-GENTR02
         MACRO
         $MENDDO2
         COPY  $MGBLDEF
         LCLC  &X
&$MDGERR SETA  0                   RESET TO 0
         AIF   (&$MDGLVL GT 0).AOK IF NOT GT 0 THEN NOTHING TO DO
         MNOTE 8,'ATTEMPT TO END NON-EXISTENT DO-GROUP(S)'
&$MDGERR SETA  8                   SHOW ERROR OCCURRED
         MEXIT
.AOK     AIF   ('&$MLTAG(&$MDGLVL)' EQ '').SKIP10
         J     &$MLTAG(&$MDGLVL)   RETURN TO 'DO'
&$MLTAG(&$MDGLVL) SETC ''          NULLIFY
.SKIP10  ANOP
&X       SETC  '$MD&$MIFELS(&$MDGLVL)&$MDGSEQ(&$MDGLVL)'
&X       DC    0H'0'               DEFINE END OF CONDITIONAL GROUP
&$MCVERB(&$MDGLVL) SETC ''
         AIF   ('&$MFNBR(&$MDGLVL)' EQ '').SKIP30
&X       SETC  '$MDF&$MFNBR(&$MDGLVL)'
&$MFNBR(&$MDGLVL) SETC ''
&X       DC    0H'0'               DEFINE TAG FOR 'ELSEIF' STATEMENTS
.SKIP30  ANOP
&$MDGLVL SETA  &$MDGLVL-1
         MEND
./ ADD NAME=$MGBLDEF 0134-01331-02095-1529-00104-00009-00000-GENTR02
.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
.* THIS COPY MEMBER CONTAINS THE GLOBAL SET SYMBOLS REQUIRED BY THE  *
.* MACROS IN THIS LIBRARY. AT IT'S FIRST INVOCATION WITHIN AN        *
.* ASSEMBLY, IT COPIES 6 MACRO DEFINITIONS THAT ARE CALLED FROM      *
.* WITHIN THE OTHER MACROS DEFINED IN THE LIBRARY.                   *
.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
         GBLA  &$MDGLVL,&$MDGERR,&$MRECUR,&$MCPYSW,&$MBLATH,&$MAXRC
         GBLC  &$MFNBR(31),&$MDGNAM(255),&$MDGSEQ(255),&$MNAME,&$MNC
         GBLC  &$MIFELS(255),&$MLTAG(255),&$MPNAM1(31),&$MFNAM1(31)
         GBLC  &$MCVERB(255),&$MC,&$MLOCTR
         AIF   (&$MCPYSW EQ 1).END999 THIS HOOPLA IS JUST TO PREVENT
&$MCPYSW SETA  (1)      THESE GUYS FROM APPEARING IN THE MEMBER LIST.
         AIF   ('&$MLOCTR' NE '').SKIP010 DON'T OVERLAY
&$MLOCTR SETC  '$$DATA$$'          DEFAULT VALUE FOR DATA LOCTR
.SKIP010 PUSH  PRINT  *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
         PRINT OFF    *=* COPY INTERNAL MACROS INTO THIS ASSEMBLY *=*
         MACRO
&NAME    $MENDDO1 &DOGROUP=
         GBLA  &$MDGLVL,&$MDGERRR
         GBLC  &$MDGNAM(255)
         LCLA  &J
&$MDGERR SETA  0                   ASSUME NO ERROR
&J       SETA  &$MDGLVL
         AIF   (&J GT 0).OK02
   MNOTE 8,'NO ACTIVE CR-GROUP TO TERMINATE - MACRO GENERATION ABORTED'
&$MDGERR SETA  4                   WARN OTHERS
         MEXIT
.OK02    AIF   ('&DOGROUP' EQ '').SKIP15
         AIF   ('&DOGROUP' NE '*ALL*').TEST10 FALL THROUGH IF *ALL*
&J       SETA  1                   END ALL BUT OUTERMOST DO-GROUP
         AGO   .SKIP20             ENTER COMMON LOOP
.TEST10  AIF   ('&DOGROUP' EQ '&$MDGNAM(&J)').SKIP20
&J       SETA  &J-1
         AIF   (&J GE 1).TEST10
         MNOTE 8,'ATTEMPT TO END NON-EXISTANT DO-GROUP ''&DOGROUP'''
         MNOTE 0,'ALL ACTIVE DO-GROUPS TERMINATED'
&J       SETA  1
         AGO   .SKIP20
.SKIP15  AIF   ('&NAME' EQ '').ENDIT DO NOTHING IF ONLY 1 LEVEL
&NAME    DC    0H'0'               WELL, MAYBE A TAG...
         MEXIT
.SKIP20  AIF   ('&NAME' EQ '').LOOP30
&NAME    DC    0H'0'         *=*=* DEFINE END OF DO-GROUP *=*=*
.LOOP30  AIF   (&J GE &$MDGLVL).ENDIT END 1 BEFORE LAST LEVEL
         $MENDDO2                  END 1 LEVEL
         AIF   (&$MDGERR NE 0).ENDIT QUIT IF ERROR OCCURRED
         AIF   (&$MDGLVL LE 1).ENDIT
         AGO   .LOOP30
.ENDIT   MEND
         MACRO
         $MENDDO2
         GBLA  &$MDGLVL,&$MDGERR
         GBLC  &$MFNBR(31),&$MDGSEQ(255),&$MIFELS(255),&$MLTAG(255)
         GBLC  &$MCVERB(255)
         LCLC  &X
&$MDGERR SETA  0                   RESET TO 0
         AIF   (&$MDGLVL GT 0).AOK IF NOT GT 0 THEN NOTHING TO DO
         MNOTE 4,'ATTEMPT TO END NON-EXISTENT DO-GROUP(S)'
&$MDGERR SETA  4                   SHOW ERROR OCCURRED
         MEXIT
.AOK     AIF   ('&$MLTAG(&$MDGLVL)' EQ '').SKIP10
         J     &$MLTAG(&$MDGLVL)   RETURN TO 'DO'
&$MLTAG(&$MDGLVL) SETC ''          NULLIFY
.SKIP10  ANOP
&X       SETC  '$MD&$MIFELS(&$MDGLVL)&$MDGSEQ(&$MDGLVL)'
&X       DC    0H'0'         *=*=* DEFINE END OF DO-GROUP *=*=*
&$MCVERB(&$MDGLVL) SETC ''
         AIF   ('&$MFNBR(&$MDGLVL)' EQ '').SKIP30
&X       SETC  '$MDF&$MFNBR(&$MDGLVL)'
&$MFNBR(&$MDGLVL) SETC ''
&X       DC    0H'0'               DEFINE TAG FOR 'ELSEIF' STATEMENTS
.SKIP30  ANOP
&$MDGLVL SETA  &$MDGLVL-1
         $MLVLMSG &$MDGLVL,NESTING
         MEND
         MACRO
         $MGFNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'
         GBLA  &$MRECUR
         GBLC  &$MFNAM1(31)
&$MFNAM1(&$MRECUR) SETC  '$MDF&SYSNDX' COMPARE-FAILED TAG
         MEND
         MACRO
         $MGFNBR &DUMMY            CREATE A UNIQUE TAG FOR 'ELSEIF'
         GBLA  &$MDGLVL
         GBLC  &$MFNBR(31)
&$MFNBR(&$MDGLVL) SETC '&SYSNDX'   CREATE UNIQUE SEQUENCE NUMBER
         MEND
         MACRO
         $MGPNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'
         GBLA  &$MRECUR
         GBLC  &$MPNAM1(31)
&$MPNAM1(&$MRECUR) SETC  '$MDP&SYSNDX' COMPARE-SUCCEEDED TAG
         MEND
         MACRO
         $MLVLMSG &LVL,&TYPE       &TYPE MUST BE 'NESTING' OR
.*                                 . 'RECURSION'
         GBLA  &$MBLATH            USER CONTROLS MNOTES WITH THIS
         AIF   (&$MBLATH LT 10).MEND999 NO MNOTE IF < 10
         AIF   ('&TYPE' EQ 'NESTING').GEN010 ISSUE MNOTE IF EQUAL
         AIF   (&$MBLATH LT 12).MEND999 NO 'RECURSION' IF < 12
.GEN010  MNOTE '==> &LVL <== IS CURRENT &TYPE LEVEL'
.MEND999 MEND
         POP   PRINT  *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
.END999  ANOP
./ ADD NAME=$MGFNAME
         MACRO
         $MGFNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'
         COPY  $MGBLDEF
&$MFNAM1(&$MRECUR) SETC  '$MDF&SYSNDX' COMPARE-FAILED TAG
         MEND
./ ADD NAME=$MGFNBR
         MACRO
         $MGFNBR &DUMMY            CREATE A UNIQUE TAG FOR 'ELSEIF'
         COPY  $MGBLDEF            COPY IN ALL THE SYMBOLS
&$MFNBR(&$MDGLVL) SETC '&SYSNDX'   CREATE UNIQUE SEQUENCE NUMBER
         MEND
./ ADD NAME=$MGPNAME
         MACRO
         $MGPNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'
         COPY  $MGBLDEF
&$MPNAM1(&$MRECUR) SETC  '$MDP&SYSNDX' COMPARE-SUCCEEDED TAG
         MEND
./ ADD NAME=@FILE550 0103-02058-02058-1342-00036-00036-00000-GENTR02
//***FILE 550 is the Structured Assembler Macros collection from    *   FILE 550
//*           Dan Snyder.  If you have been tempted to use the      *   FILE 550
//*           IBM HLASM Toolkit set of structured macros, but you   *   FILE 550
//*           were afraid that you'd have to assemble your code     *   FILE 550
//*           in a place that wasn't licensed for the Toolkit,      *   FILE 550
//*           then you might try these macros as an alternative.    *   FILE 550
//*                                                                 *   FILE 550
//*           These macros (IF, DO, etc) are not interchangeable    *   FILE 550
//*           with the IBM macros from the HLASM toolkit.  You      *   FILE 550
//*           either use ALL THESE, or ALL THEIRS, but don't mix    *   FILE 550
//*           them....                                              *   FILE 550
//*                                                                 *   FILE 550
//*           The advantage of using this set of structured macros  *   FILE 550
//*           is that they are FREE and that they offer a powerful  *   FILE 550
//*           method of nesting conditions. You can assemble with   *   FILE 550
//*           them at any site....                                  *   FILE 550
//*                                                                 *   FILE 550
//*           For support, you may contact the author, Dan Snyder,  *   FILE 550
//*           at:                                                   *   FILE 550
//*                                                                 *   FILE 550
//*           email:   dsnyder@elektro.cmhnet.org                   *   FILE 550
//*                    Dan_Snyder@stercomm.com                      *   FILE 550
//*                                                                 *   FILE 550
//*     - - - - - - - - - - - - - - - - - - - - - - - - - - -       *   FILE 550
//*                                                                 *   FILE 550
//*     Names of the macros in the Structured Macro Set:            *   FILE 550
//*                                                                 *   FILE 550
//*         AFTER    BEGTEST  DO       DOCUMENT DOEXIT              *   FILE 550
//*         ELSE     ELSEDO   ELSEIF   ENDAFTER ENDELSE             *   FILE 550
//*         ENDEVERY ENDFIRST ENDIF    ENDO     ENDTEST             *   FILE 550
//*         EVERY    EXECUTE  FIRST    IF       THENDO              *   FILE 550
//*                                                                 *   FILE 550
//*      and the auxiliary copy member to assist these:             *   FILE 550
//*                                                                 *   FILE 550
//*         $GBLDEF                                                 *   FILE 550
//*                                                                 *   FILE 550
./ ADD NAME=AFTER    0112-01257-02070-1317-00034-00039-00000-GENTR02
         MACRO
&NAME    AFTER &VAR
         COPY  $MGBLDEF            BRING IN THE CLOWNS
&LCLV    SETC  '&VAR'              SET TO COUNT
         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING
         MNOTE 8,'''&VAR'' NOT SELF-DEFINING: 'AFTER' GROUP WILL BE PROC
               CESSED EACH PASS THROUGH THIS SECTION OF CODE'
&LCLV    SETC  '0'                 DO EVERY TIME
.OK30    ANOP
&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL
         $MLVLMSG &$MDGLVL,NESTING
&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'
&$MIFELS(&$MDGLVL) SETC 'F'
&$MDGNAM(&$MDGLVL) SETC '&NAME'
&$MCVERB(&$MDGLVL) SETC 'AFTER'
&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY
         AIF   ('&LCLV' NE '1').PACKED
&NAME    TM    &X,X'01'            HAVE WE BEEN HERE BEFORE?
         JO    *+12                SKIP OVER IS YES
         OI    &X,X'01'            ELSE LEAVE TRACKS
         J     $MDF&SYSNDX           AND BYPASS DO-GROUP
         AGO   .DEFINE
.PACKED  ANOP                      I GUESS WE'LL HAVE TO DO DECIMAL...
&NAME    SP    &X,=P'1'            DECREMENT
         JNM   $MDF&SYSNDX         B IF NOT YET TIME
         PACK  &X,=Z'0'            DO EVERY TIME FROM NOW ON
&$MLOCTR LOCTR                     SET UP WORK AREA
         AIF   ('&LCLV' NE '1').PACKED2
&X       DC    X'00'               SET TO X'01' FIRST TIME THROUGH
         AGO   .INST
.PACKED2 ANOP
&X       DC    P'&LCLV'            FREQUENCY COUNTER
&SYSECT  LOCTR                     BACK TO INSTRUCTION AREA
         MEND
./ ADD NAME=BEGTEST  0118-01330-02079-1022-00057-00064-00000-GENTR02
         MACRO
&NAME    BEGTEST &LVL,                                                 C
               &PRINT=        CODE 'PRINT=NO' TO SUPPRESS SKIPPED STMTS
.* OR 'PRINT=YES' TO PRINT SKIPPED STMTS OR CHANGE IT IN THIS MACRO
.* DEFINITION TO CHANGE IT TO SAY '&PRINT=NO' TO MAKE 'NO' THE DEFAULT
.*
.*                              IN 'OPEN' CODE DO ONE OF THE FOLLOWING:
         GBLA  &TESTLVL         1. SET TO > 0 TO ACTIVATE - OR -
         GBLC  &$A,&$B,&$C,&$D  2. SET ONE OR MORE TO 'Y' TO ACTIVATE
         GBLC  &$MPRSW          TO KEEP TRACK OF USER'S PREF
         LCLA  &I,&J
         LCLC  &TEXT
         AIF   ('&PRINT' EQ '').SKIP005 GO IF NO PARM SPECIFIED
&$MPRSW  SETC  '&PRINT'                SET GLOBAL TO USER'S VALUE
.SKIP005 AIF   ('&NAME' EQ '').SKIP010
&NAME    EQU   *
.SKIP010 AIF   ('&LVL' NE '' AND '&LVL'(1,1) GT 'Z').TEST510
         AIF   ('&LVL' NE 'A').TEST020 FALL THRU IF 'A'
         AIF   ('&$A' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST
         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST
.TEST020 AIF   ('&LVL' NE 'B').TEST030 FALL THRU IF 'B'
         AIF   ('&$B' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST
         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST
.TEST030 AIF   ('&LVL' NE 'C').TEST040 FALL THRU IF 'C'
         AIF   ('&$C' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST
         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST
.TEST040 AIF   ('&LVL' NE 'D').MSG050  FALL THRU IF 'D'
         AIF   ('&$D' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST
         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST
.MSG050  MNOTE *,' ---> INVALID CHAR OPERAND &LVL - OPT CODE INCLUDED'
         AGO   .MEND999
.TEST510 AIF   (&LVL LE &TESTLVL).MEND999 IF LE THEN INCL THRU ENDTEST
.LOOP520 AIF   ('&$MPRSW' EQ 'YES').NEXT523 'DEFAULT' IS SUPPRESS
&TEXT    AREAD NOPRINT            READ STMT AND SUPPRESS PRINT
         AGO   .NEXT526
.NEXT523 ANOP
&TEXT    AREAD NOSTMT            READ AND PRINT STMT BUT NO LINE NUMBER
.NEXT526 AIF   ('&TEXT'(1,1) EQ '*').LOOP520 SKIP COMMENT STMTS
&J       SETA  &J+1                    COUNT THIS STMT
&I       SETA  1                       GET READY TO INSPECT STMT
.LOOP530 AIF   ('&TEXT'(&I,1) EQ ' ').NEXT540 SCAN PAST NAME FIELD
&I       SETA  &I+1                    INCR PTR TO NEXT POS
         AIF   (&I GT 65).LOOP520      GET NEXT STMT IF COL 65
         AGO   .LOOP530                KEEP SCANNING NAME FIELD
.NEXT540 AIF   ('&TEXT'(&I,1) NE ' ').NEXT550 SCAN PAST LEADING SPACES
&I       SETA  &I+1                    INCR TO NEXT POS
         AIF   (&I GT 65).LOOP520      GET NEXT STMT IF COL 65
         AGO   .NEXT540                KEEP SCANNING SPACES
.NEXT550 AIF   ('&TEXT'(&I,8) NE 'ENDTEST ').LOOP520 SECRET KEYWORD?
&J       SETA  &J-1                    YES - DECREMENT IMAGE COUNT
         AIF   (&J NE 1).MSG560        FORMAT NICELY
         MNOTE *,' ===> ENDTEST STATEMENT ENCOUNTERED - 1 STATEMENT SKIX
               PPED'
         AGO   .MEND999
.MSG560  MNOTE *,' ===> ENDTEST STATEMENT ENCOUNTERED - &J STATEMENTS SX
               KIPPED'
.MEND999 MEND
./ ADD NAME=DO       0116-01331-02079-1254-00127-00124-00000-GENTR02
         MACRO
&NAME    DO    &VAR,&WHILE=,&UNTIL=,&TEST=BEFORE
         COPY  $MGBLDEF            BRING IN THE CLOWNS
         LCLA  &Y
         LCLC  &X
         AIF   ('&TEST' EQ 'BEFORE').TEST10
         AIF   ('&TEST' EQ 'AFTER').TEST10
         MNOTE 8,'''TEST=&TEST'' INVALID - ''BEFORE'' ASSUMED'
.TEST10  AIF   ('&WHILE' NE '').TEST20 GO IF &WHILE SPECIFIED
         AIF   ('&UNTIL' NE '').TEST22  GO IF &UNTIL SPECIFIED
         AIF   ('&VAR' NE '').OK30 GO IF &VAR SPECIFIED
         MNOTE 4,'NO ENDING CONDITION - POSSIBLE UNENDING LOOP'
         AGO   .OK30               CONTINUE
.TEST20  AIF   ('&UNTIL' NE '').ERR90 GO IF &UNTIL SPECIFIED
.TEST22  AIF   ('&VAR' NE '').ERR90 GO IF &VAR SPECIFIED
         AIF   ('&WHILE' NE '').CONT50
.OK30    AIF   ('&UNTIL' NE '').CONT60
&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL
         $MLVLMSG &$MDGLVL,NESTING
&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'
&$MIFELS(&$MDGLVL) SETC 'F'
&$MDGNAM(&$MDGLVL) SETC '&NAME'
&$MCVERB(&$MDGLVL) SETC 'DO'
&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME
&$MLTAG(&$MDGLVL) SETC '&$MNAME'   SET LOOP RETURN TAG
         AIF   ('&VAR' EQ '').CLEAN99 GO IF NO &VAR SPECIFIED
         AIF   ('&VAR'(1,1) GE '0').SELF40 GO IF SELF-DEFINING
.*                                 - (MUST BE PACKED DECIMAL)
         AIF   ('&VAR' NE 'FOREVER').NEXT32 GO IF NOT FOREVER
         AIF   ('&NAME' EQ '').SKIP31
&NAME    DS    0H                  FALL THRU TO BEGINNING OF DO-GROUP
.SKIP31  ANOP
&$MNAME  DS    0H                  BEGINNING OF DO-GROUP
         AGO   .CLEAN99
.NEXT32  ANOP
&NAME    PACK  $MDV&SYSNDX,=Z'0'   START WITH 0 THEN ADD 1
         ZAP   $MDM&SYSNDX,&VAR    PROTECT VARIABLE FROM CHANGE
         AIF   ('&TEST' NE 'AFTER').SKIP35
         EX    0,*+8               BUMP BY 1
         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE
.SKIP35  ANOP
&$MNAME  AP    $MDV&SYSNDX,=P'1'   BUMP BY 1
&$MNAME  SETC  ''                  SET NAME TO NULL
&X       SETC  '$MDM&SYSNDX'       NAME FOR CELL FOR END VALUE
         CP    $MDV&SYSNDX,&X      FINISHED?
         JH    $MDF&SYSNDX         B IF YES
&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA
&Y       SETA  L'&VAR              MAKE SURE OUR VARIABLE IS BIG ENOUGH
&X       DC    PL(&Y+1)'0'         CELL TO SAVE END VALUE
&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY
&X       DC    PL(&Y+1)'0'         LOOP COUNTER
&SYSECT  LOCTR                     RESUME INSTRUCTION AREA
         AGO   .CLEAN99
.SELF40  ANOP
&NAME    PACK  $MDV&SYSNDX,=Z'0'   START WITH 0 THEN ADD 1
         AIF   ('&TEST' NE 'AFTER').SKIP46
         EX    0,*+8               BUMP BY 1
         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE
.SKIP46  ANOP
&$MNAME  AP    $MDV&SYSNDX,=P'1'   BUMP BY 1
&$MNAME  SETC  ''                  SET NAME TO NULL
         CP    $MDV&SYSNDX,=P'&VAR' FINISHED?
         JH    $MDF&SYSNDX         B IF YES
&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA
&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY
&X       DC    P'0&VAR'            LOOP COUNTER
&SYSECT  LOCTR                     RESUME INSTRUCTION AREA
         AGO   .CLEAN99
.CONT50  ANOP  &WHILE OPTION WAS SPECIFIED
&$MNAME  SETC  '&NAME'             SET TO GIVEN NAME
         AIF   ('&NAME' NE '').CONT52 NO TAG -> NO DC
&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME
.CONT52  ANOP
&Y       SETA  &$MDGLVL+1          SET TO NEXT HIGHER
&$MLTAG(&Y) SETC '&$MNAME'         SET TO LOOP NAME
         AIF   ('&TEST' NE 'AFTER').SKIP53
         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE
.SKIP53  AIF   ('&WHILE'(2,1) EQ '(').CONT54
&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'
&$MNAME  IF    &WHILE,THENDO       PASS PARMS TO 'IF'
         AGO   .CLEAN99            WRAP IT UP
.CONT54  ANOP
&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'
&$MNAME  IF    &WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),                C
               &WHILE(5),&WHILE(6),&WHILE(7),&WHILE(8),                C
               &WHILE(9),&WHILE(10),&WHILE(11),&WHILE(12),             C
               &WHILE(13),&WHILE(14),&WHILE(15),&WHILE(16),            C
               &WHILE(17),&WHILE(18),&WHILE(19),&WHILE(20),            C
               &WHILE(21),&WHILE(22),&WHILE(23),&WHILE(24)
         AGO   .CLEAN99
.CONT60  ANOP  &UNTIL OPTION WAS SPECIFIED
&$MNAME  SETC  '&NAME'             SET TO GIVEN NAME
         AIF   ('&NAME' NE '').CONT62 NO TAG -> NO DC
&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME
.CONT62  ANOP
&Y       SETA  &$MDGLVL+1          SET TO NEXT HIGHER
&$MLTAG(&Y) SETC '&$MNAME'         SET TO LOOP NAME
         AIF   ('&TEST' NE 'AFTER').SKIP63
         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE
.SKIP63  AIF   ('&UNTIL'(2,1) EQ '(').CONT64
&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'
&$MNAME  IF    &UNTIL,THENDO       PASS PARMS TO 'IF'
         J     $MDF&SYSNDX         CONDITION MET - EXIT LOOP
&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' PREV 'FAILED' TAG
&X       DC    0H'0'               'UNTIL' FAILED - ENTER DO-GROUP
&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  NEW UNIQUE TAG
         AGO   .CLEAN99            WRAP IT UP
.CONT64  ANOP
&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'
&$MNAME  IF    &UNTIL(1),&UNTIL(2),&UNTIL(3),&UNTIL(4),                C
               &UNTIL(5),&UNTIL(6),&UNTIL(7),&UNTIL(8),                C
               &UNTIL(9),&UNTIL(10),&UNTIL(11),&UNTIL(12),             C
               &UNTIL(13),&UNTIL(14),&UNTIL(15),&UNTIL(16),            C
               &UNTIL(17),&UNTIL(18),&UNTIL(19),&UNTIL(20),            C
               &UNTIL(21),&UNTIL(22),&UNTIL(23),&UNTIL(24)
         J     $MDF&SYSNDX         CONDITION MET - EXIT LOOP
&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' PREV 'FAILED' TAG
&X       DC    0H'0'               'UNTIL' FAILED - ENTER DO-GROUP
&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  NEW UNIQUE TAG
         AGO   .CLEAN99            WRAP IT UP
.ERR90   MNOTE 12,'MUTUALLY EXCLUSIVE PARAMETERS - MACRO ABORTED'
         AGO   .MEND990
.CLEAN99 ANOP
         AIF   ('&TEST' NE 'AFTER').MEND990
&X       SETC  '&SYSNDX'           FOR ALIGNMENT PURPOSES ONLY
$MDD&X   DC    0H'0'               BEGINNING OF DO-GROUP
.MEND990 MEND
./ ADD NAME=DOCUMENT 0129-01226-02072-1549-00707-01634-00000-GENTR02
THIS MEMBER IS AN INTRODUCTION TO THE MACRO DEFINITIONS WHICH COMPRISE
THE REMAINING MEMBERS OF THIS LIBRARY.  EACH OF THE MACROS HAS BEEN
TESTED, FOUND TO OPERATE CORRECTLY, AND TO PROVIDE AT LEAST SOME
MINIMUM AMOUNT OF DESIRABLE FUNCTIONALITY.  IF A PROBLEM CROPS UP,
EITHER IN YOUR UNDERSTANDING HOW TO USE A PARTICULAR MACRO OR GROUP OF
MACROS, OR WITH APPARENT PROGRAMMING PROBLEMS WITH THE PACKAGE, PLEASE
FEEL FREE TO CONTACT THE AUTHOR (NOTE THESE MACROS ARE NOT COPYWRITED):

          DAN SNYDER                  614-847-8212
          COMPUWARE CORP              dsnyder@elektro.cmhnet.org
          1103 SCHROCK ROAD, STE 205
          COLUMBUS, OH 43229

THE FOLLOWING IS A DESCRIPTION OF THE CATEGORIES THAT THESE MACROS HAVE
BEEN CLASSIFIED INTO:

INTERNAL - THESE MACROS ARE TYPICALLY USED AS COMMON SERVICE ROUTINES
BY OTHER MACROS WITHIN THIS LIBRARY.  THEY PROVIDE SERVICES THAT WOULD
NOT NORMALLY BE CALLED FROM OPEN CODE. THEY ARE AUTOMATICALLY COPIED
INTO THE ASSEMBLE THE FIRST TIME THAT $GBLDEF IS COPIED INTO A MACRO
THAT IS BEING EXPANDED.

STRUCTURED - MACROS THAT CONTROL THE CONDITIONAL OR REPETITIVE
EXECUTION OF A GROUP OF INSTRUCTIONS FOLLOWING THE GROUP-INITIATION
MACRO AND ENDING WITH A GROUP-TERMINATING MACRO. SEVERAL MACROS IN THIS
FAMILY GENERATE A 'LOCTR' STATEMENT NAMED 'DATA' TO ALLOW THE OUT-OF-LINE
GENERATION OF REQUIRED CONSTANTS AND VARIABLES.  THE NAME OF THE LOCTR
CAN BE CHANGED TO LOCAL REQUIREMENTS IN THE $MGBLDEF MEMBER.

DIAGNOSTIC - THE 'BEGTEST' AND 'ENDTEST' MACROS ALLOW YOU TO CONDITIONALLY
INCLUDE OR EXCLUDE SECTIONS OF CODE FROM A PARTICULAR ASSEMBLY.  THE CODE
CAN CONTINUE TO EXIST IN THE SOURCE MODULE. YOU COULD INCLUDE ONE
SECTION OF CODE FOR MVS SYSTEMS, AND ANOTHER FOR VSE.  THIS FACILITY
PROVIDES A 'STRUCTURED' EQUIVALENT OF HAVING 'AGO' OR 'AIF' STATEMENTS
TARGETTING LABELLED 'ANOP' STATEMENTS WITHIN YOUR CODE.

GENERAL - THE 'EXECUTE' MACRO ALLOWS THE PROGRAMMER TO CREATE AN 'EX'
STATEMENT ON ONE LINE OF CODE.  IT GENERATES A 'LOCTR' STATEMENT NAMED
'DATA' TO ALLOW THE OUT-OF-LINE GENERATION OF THE 'EX'ECUTED INSTRUCTION.
THE NAME OF THE LOCTR AREA CAN BE CHANGED TO LOCAL REQUIREMENTS.

IN EACH OF THE EXAMPLES, IF '<NAME>' IS DISPLAYED IN THE NAME FIELD
OF A MACRO DEFINITION, THEN THE NAME FIELD IS A SUPPORTED OPTION FOR
THAT MACRO.

WHAT FOLLOWS IS A MOSTLY ALPHABETICAL LISTING OF ALL OF THE MACRO
DEFINITIONS INCLUDED IN THE PACKAGE, WITH ITS IDENTIFYING MACRO TYPE:

$MGBLDEF  INTERNAL (GLOBAL SET SYMBOL DEFINITIONS AND INTERNAL MACROS)
AFTER     STRUCTURED
BEGTEST   DIAGNOSTIC
DO        STRUCTURED
DOEXIT    STRUCTURED
DONEXT    STRUCTURED
ELSE      STRUCTURED
ELSEDO    STRUCTURED
ELSEIF    STRUCTURED
ENDAFTER  STRUCTURED
ENDELSE   STRUCTURED
ENDEVERY  STRUCTURED
ENDFIRST  STRUCTURED
ENDIF     STRUCTURED
ENDO      STRUCTURED
ENDTEST   DIAGNOSTIC
EVERY     STRUCTURED
EXECUTE   GENERAL
FIRST     STRUCTURED
IF        STRUCTURED
THENDO    STRUCTURED

                            DIAGNOSTIC

THE MACROS IN THIS GROUP FURNISH VARIOUS AIDS THAT CAN BE USED IN
DIAGNOSING THE EXECUTION OF A PROGRAM.  THE 'BEGTEST' AND 'ENDTEST'
MACROS ALLOW MULTIPLE LINES OF CODE TO BE INCLUDED OR EXCLUDED FROM
AN ASSEMBLY, BASED ON THE VALUE OF A GLOBAL SET SYMBOL.

BEGTEST
THIS MACRO HEADS A GROUP OF INSTRUCTIONS THAT ARE CONDITIONALLY
INCLUDED OR EXCLUDED FROM A PARTICULAR ASSEMBLY. THE GROUP MUST BE
TERMINATED WITH AN 'ENDTEST' MACRO.  THE 'BEGTEST' REQUIRES ONE
POSITIONAL OPERAND.  IF THE OPERAND IS NUMERIC, THEN THAT VALUE IS
COMPARED WITH THE GLOBAL TYPE 'A' SET SYMBOL &TESTLVL.  IF THE OPERAND
IS GREATER THAN &TESTLVL, THEN THE INSTRUCTIONS BETWEEN THE 'BEGTEST'
AND 'ENDTEST' ARE EXCLUDED FROM THIS ASSEMBLY, OTHERWISE THEY ARE
INCLUDED:

          GBLA  &TESTLVL
 &TESTLVL SETA  10
 ...
<NAME>    BEGTEST 5,PRINT=YES
          WTO   'HELP'
<NAME>    ENDTEST ,

IN THIS CASE, THE 'WTO' STATEMENT WILL BE ASSEMBLED.  IF &TESTLVL HAD
BEEN SET TO 0 (ZERO), THEN THE 'WTO' WOULD HAVE BEEN EXCLUDED FROM
THIS ASSEMBLY.  THE PARAMETER 'PRINT=YES' CAUSES EACH STATEMENT
SKIPPED TO BE LISTED AS A COMMENT (A '-' IS PRINTED IN THE LISTING
PRECEDING COLUMN 1 OF THE STATEMENT).

BE VERY CAREFUL ABOUT GIVING A NAME TO THE 'ENDTEST' MACRO.  IF YOU
CODE A BRANCH INSTRUCTION WITH THAT NAME AS THE OPERAND, AND THAT
'ENDTEST' INSTRUCTION IS OMITTED FROM THE PROGRAM BECAUSE OF THE VALUE
OF &TESTLVL, THEN YOU WILL GET AN ASSEMBLY ERROR.  IT WOULD BE SAFE TO
HAVE A BRANCH TO THAT TAG ONLY WITHIN THE GROUP OF INSTRUCTIONS HEADED
BY THE 'BEGTEST' MACRO.

IF THE VALUE OF THE POSITIONAL OPERAND OF THE 'BEGTEST' IS 'A', 'B',
'C', OR 'D', THEN THE LOGIC IS BASED ON THE SETTING OF THE GLOBAL TYPE
'C' SET SYMBOL &$A, &$B, &$C OR &$D RESPECTIVELY:

          GBLC  &$A
&$A       SETC  'Y'     ANY OTHER VALUE CAUSES EXCLUSION
...
<NAME>    BEGTEST A,PRINT=NO
          WTO   'OPT CODE INCLUDED'
<NAME>    ENDTEST ,

SINCE THE SET SYMBOL &$A WAS SET TO 'Y', THE 'WTO' WILL BE INCLUDED IN
THIS ASSEMBLY.  IF &$A HAD BEEN SET TO ANY OTHER VALUE THEN THE CODE
WOULD NOT BE INCLUDED IN THIS ASSEMBLY.  THE 'PRINT=NO' PARAMETER
PREVENTS THE SKIPPED STATEMENTS FROM BEING PRINTED.

&$A       SETC  'N'     ONLY 'Y' CAUSES INCLUSION
...
<NAME>    BEGTEST A
          WTO   'OPT CODE EXCLUDED'
<NAME>    ENDTEST ,

SINCE THE SET SYMBOL &$A WAS SET TO 'N', THE 'WTO' WILL BE EXCLUDED.

NOTE: WHEN YOU CODE A 'PRINT=YES/NO' PARAMETER ON THE BEGTEST
STATEMENT, THAT OPTION REMAINS IN EFFECT FOR THE REMAINING 'BEGTEST'
MACROS UNTIL ANOTHER 'PRINT=YES/NO' CLAUSE IS ENCOUNTERED. IF YOU
PREFER TO CONTROL THE PRINTING OF SKIPPED INSTRUCTIONS AT THE
BEGINNING OF YOUR PROGRAM, YOU MAY DO SO BY:

         GBLC  &$MPRSW
&$MPRSW  SETC  'NO'       TO SUPPRESS PRINTING SKIPPED INSTRUCTIONS
&$MPRSW  SETC  'YES'      TO CAUSE THE PRINTING SKIPPED INSTRUCTIONS

CHOOSE THE 'SETC' STATEMENT THAT PROVIDES THE OPTION THAT YOU WANT.

ENDTEST
THIS ONE NEEDS TO BE USED ONLY IN CONJUNCTION WITH THE 'BEGTEST'
MACRO. IT IS USED TO END A GROUP OF CONDITIONALLY INCLUDED LINES OF
CODE. PLEASE SEE THE DOCUMENTATION FOR 'BEGTEST'.

EXECUTE
THIS ONE MAKES IT POSSIBLE TO CONSTRUCT AN 'EX' INSTRUCTION WITH ONE
LINE OF CODE.  IF YOU'VE NEVER USED THE 'EX' INSTRUCTION, YOU'RE
PROBABLY BETTER OFF SKIPPING THE REST OF THIS 'EXECUTE' DOCUMENTATION.
IF YOU HAVE ALREADY USED IT, OR IF YOU'RE VERY BRAVE, THEN HERE GOES.
IT REQUIRES THREE POSITIONAL OPERANDS. THE FIRST IS A GPR (IT DOESN'T
HAVE TO BE WITHIN PARENTHESES, SINCE IT HAS TO BE A GPR), THE SECOND
IS THE OP CODE FOR THE INSTRUCTION BEING 'EX'ECUTED, AND THE THIRD
CONSISTS OF ALL OF THE OPERANDS OF THE INSTRUCTION BEING 'EX'ECUTED,
AND THEY MUST BE ENCLOSED WITHIN PARENTHESES.

 <NAME>   EXECUTE R15,MVC,(FIELDA(0),FIELDB)
+<NAME>   EX     R15,$EX1234         GENERATED
+...
+$EX1234  MVC   FIELDA(0),FIELDB     GENERATED

NOTE THAT THE THIRD OPERAND IS GENERATED OUT-OF-LINE.

                            INTERNAL

THESE MACRO DEFINITIONS ARE FURNISHED WITHIN THE COPY MEMBER '$MGBLDEF' AND
ARE INCLUDED INTO THE ASSEMBLY THE FIRST TIME THAT A COPY STATEMENT FOR THAT
MEMBER IS ENCOUNTERED IN YOUR PROGRAM.  THUS THE FIRST 'IF' STATEMENT (OR
OTHER STRUCTURED MACRO) WILL CAUSE THESE TO BE INCLUDED.

                            STRUCTURED

THIS SET OF MACROS CAUSES A CONDITIONAL AND/OR REPETITIVE EXECUTION OF
A GROUP OF ONE OR MORE INSTRUCTIONS.  FOR CONVENIENCE, LET'S CALL A
GROUP OF INSTRUCTIONS THAT MIGHT OR MIGHT NOT BE EXECUTED ONE TIME, OR
MULTIPLE TIMES, A 'CR-GROUP', FOR 'C'ONDITIONAL/'R'EPETITIVE.

MNOTE STATEMENTS ARE ISSUED WHEN A POTENTIAL PROBLEM IS DETECTED. IF
THE MNOTE CODE IS 0 THEN IT REPRESENTS AN INFORMATIONAL MESSAGE. IF IT
IS 4, THEN THE CODE GENERATED IS PROBABLY CORRECT, BUT SHOULD BE
EXAMINED. IF IT IS 8, THEN A LIKELY ERROR EXISTS AND SHOULD BE
CORRECTED.  IF IT IS 12, THEN THE CODE GENERATED WILL BE INCORRECT
AND/OR INCOMPLETE, AND THE STATEMENT RESPONSIBLE MUST BE CORRECTED.

IF
THIS IS THE HEART OF THE STRUCTURED MACROS. IT SUPPORTS THE
CONDITIONAL EXECUTION OF A CR-GROUP BASED ON ONE OR MORE TESTS. EACH
TEST PHRASE, CONTAINED WITHIN PARENTHESES, MUST CONSIST OF AN OP-CODE,
A FIRST OPERAND, A SECOND OPERAND, AND A CONDITION. (NOTE OP-CODES
WITH OTHER THAN TWO OPERANDS ARE SUPPORTED, BUT THE OP-CODE MUST
ALWAYS BE FIRST AND THE CONDITION MUST ALWAYS BE LAST WITHIN THE
PHRASE.)  IN THE SIMPLE CASE, ONE CONDITIONAL PHRASE IS FOLLOWED BY
A 'THENDO'.  IN COMPLEX CASES, EACH ODD-NUMBERED PARAMETER MUST
CONTAIN THE INSTRUCTION SETTING THE CONDITION CODE AS SUBPARAMETERS
WITHIN PARENTHESES, AND EACH EVEN-NUMBERED PARAMETER MUST BE AN
'OR', AN 'AND', OR THE LAST PHRASE MUST BE A 'THENDO' (IF YOU OMIT
THE 'THENDO', THEN YOU WILL GET AN INFORMATIONAL MNOTE STATEMENT):

 <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO
            ...
          ENDIF ,

 <NAME>   IF    (CLC,FIELDA,FIELDB,E),OR,                     X
                (CLC,FIELDA,FIELDC,E),THENDO
            ...
          ENDIF ,

NOTE THAT THE FORMAT OF THE CONDITIONAL PHRASE IS FIXED IN THAT:
1. THE OP-CODE IS ALWAYS THE FIRST OPERAND
2. THE CONDITION IS ALWAYS LAST
3. THE OPERANDS ARE ALWAYS IN THEIR ORDINAL POSITIONS IN BETWEEN
4. IF YOU SET GLOBAL TYPE A SET SYMBOL &$MBLATH TO A VALUE GREATER
   THAN ZERO, THEN VARIOUS DIAGNOSTICS ARE MNOTED DURING THE MACRO
   GENERATION PHASE. IF YOU SET IT TO 10, THEN NESTING IS NOTED
   (SIMILAR TO COBOL IF-STATEMENT LEVELS LISTED TO THE LEFT OF THE
   SOURCE STATEMENTS). IF YOU SET IT TO 12, THEN THE RECURSION
   LEVEL OF THE 'IF' STATEMENT IS MNOTED. TO DO THIS, YOU HAVE TO
   DEFINE THE SET SYMBOL IN OPEN CODE. THIS GIVES YOU THE
   COMMUNICATION LINK TO THE SAME NAME DEFINED WITHIN THE MACRO
   LIBRARY:

         GBLA  &$MBLATH
&$MBLATH SETA  10              SHOW NESTING LEVELS
                     - OR -
&$MBLATH SETA  12              SHOW NESTING AND RECURSION LEVELS

EXAMPLES:

         IF   (UPT,Z),THENDO          INST WITH ZERO OPERANDS
+        UPT  ,
+        JNZ   ...

         IF   (SSCH,12,Z),THENDO                ONE OPERAND
+        SSCH 12
+        JNZ  ...

         IF   (CLI,LCLSW,C'0',E),THENDO         TWO OPERANDS
+        CLI  LCLSW,C'0'
+        JNE  ...

         IF   (SRP,PFIELD1,PFIELD2,5,Z),THENDO  THREE OPERANDS
+        SRP  PFIELD1,PFIELD2,5
+        JNZ  ...

IF YOU CODE THE WRONG NUMBER OF PARAMETERS FOR A PARTICULAR OP-CODE,
THEN 'THE RESULTS ARE UNPREDICTABLE', ALTHOUGH GENERALLY THE MACRO
WILL EXPAND WITHOUT NOTING THE ERROR AND YOU WILL GET AN ERROR ON
THE GENERATED INSTRUCTION.

NOTE THAT THE OP-CODE 'CLC' WILL BE USED THROUGHOUT THESE EXAMPLES.
WHEN YOU CODE YOUR PROGRAM, USE WHATEVER INSTRUCTION IS APPORPRIATE,
SO LONG AS IT IS ONE THAT SETS THE PROCESSOR'S CONDITION CODE FIELD.
IT COULD EVEN BE A MACRO STATEMENT, SO LONG AS THE CONDITION CODE
IS SET BY ONE OF THE INSTRUCTIONS GENERATED BY THE MACRO EXPANSION SO
THAT IT CAN BE TESTED BY THE BRANCH-ON-CONDITION THAT FOLLOWS.

IN THIS EXAMPLE, IF FIELDA IS EQUAL TO FIELDB, THEN THE CR-GROUP
WILL BE EXECUTED.  THE CONDITION, CODED AS THE LAST POSITIONAL
SUB-PARAMETER, CAN BE ANY OF THE EXTENDED BRANCH NMEMONICS:

  E NE H NH L NL M NM O NO P NP Z NZ

IN THE ABOVE EXAMPLE, THE MACRO EXPANDS INTO:

 <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO
+<NAME>   CLC   FIELDA,FIELDB    GENERATED
+         BNE   $TAG             BRANCH AROUND 'IF' GROUP
          ...                    YOUR INSTRUCTIONS
          ENDIF ,
+$TAG     DS    0H

NOTE: IN THIS SIMPLE EXAMPLE, THE CONDITION 'E' STATES THAT THE IF-GROUP
IS TO BE EXECUTED IF THE 'CLC' RESULTS IN AN 'EQUAL'.  TO CAUSE THIS
LOGIC TO OCCUR, A BRANCH ON THE OPPOSITE CONDITION IS CREATED TO BYPASS
THE IF-GROUP, MEANING THAT PROGRAM EXECUTION 'FALLS THROUGH' INTO THE
IF-GROUP WHEN THE SPECIFIED CONDITION IS MET.

LIKEWISE, FOR THE PHRASE '(CLC,FIELDA,FIELDB,NE)', THE BYPASSING BRANCH
INSTRUCTION GENERATED WOULD BE A 'BE    $TAG'.

NOTE: '$TAG' INDICATES THAT THE MACRO GENERATION PROCESS WILL GENERATE
AN UNIQUE TAG, WHOSE NAME BEGINS WITH '$', AND ENDS WITH A UNIQUE NUMBER
OBTAINED FROM A SYSTEM COUNTER.

IF YOU HAD CODED 'NE' AS THE CONDITION, THEN IT WOULD EXPAND TO:

 <NAME>   IF    (CLC,FIELDA,FIELDB,NE),THENDO
+<NAME>   CLC   FIELDA,FIELDB    GENERATED
+         BE    $TAG             BRANCH AROUND 'IF' GROUP
          ...                    YOUR INSTRUCTIONS
          ENDIF ,
+$TAG     DS    0H

     TO EXECUTE THE CR-GROUP IF EITHER ONE OF TWO CONDITIONS IS
TRUE, THE FORMAT IS:

 <NAME>   IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO

     ALTERNATE FORMAT:
                                                               72
 <NAME>   IF    (CLC,A,B,NE),OR,                                C
           (CLC,C,D,NE),THENDO

     NOTE THAT, AS SHOWN IN THE EXAMPLES, YOU NEED TO ENCLOSE THE
CONDITIONAL PHRASES WITHIN PARENTHESES, AND THAT YOU DO NOT
ENCLOSE THE CONNECTING PHRASES ('OR' OR 'AND') OR THE FINAL
'THENDO' WITHIN PARENTHESES.

     SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING
EXAMPLE, THE CR-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR
IF BOTH THE SECOND AND THIRD ARE TRUE:

 <NAME>   IF    (CLC,A,B,E),OR,                                 C
                (CLC,C,D,E),AND,                                C
                (CLC,E,F,E),THENDO

     IF YOU NEED TO CREATE A SUB-GROUP OF PHRASES CONNECTED BY
'OR' CONNECTORS, AND THEN CONNECT THIS SUB-GROUP VIA AN 'AND'
WITH ANOTHER CONDITION (WHICH MAY ITSELF CONSIST OF ANOTHER
SUB-GROUP OF CONDITIONS), THEN YOU NEED TO ENCLOSE THE ENTIRE
SUB-GROUP WITHIN AN ADDITIONAL PAIR OF PARENTHESES:

                * <-NESTING PARENTHESES -> *
 <NAME>   IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C
                (CLC,E,F,E),THENDO

     THE AUTHOR OF THESE MACROS PREFERS THE FORMAT:

 <NAME>   IF    ((CLC,A,B,E),OR,                                C
                (CLC,C,D,E)),AND,                               C
                (CLC,E,F,E),THENDO

     I GUESS THE BOTTOM LINE IS THAT S/390 ASSEMBLER IS SOMEWHAT OF A
PAIN, NO MATTER HOW YOU FORMAT THE STATEMENTS!

     GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED
TO DEFINE THE LOGIC DESIRED. THE LIMIT IS THE LENGTH OF A SINGLE
OPERAND SUPPORTED BY THE ASSEMBLER BEING USED.

     NOTE THAT THE CONDITIONAL PHRASES ARE EXECUTED IN THE ORDER
THAT THEY ARE WRITTEN.  THEREFORE, IF THERE ARE ONE OR MORE PHRASES
THAT MORE OFTEN THAN NOT WOULD RESULT IN AN ABBREVIATED PASS THRU THE
CONSTRUCT, THEN YOU SHOULD CODE THOSE PHRASES FIRST (MAINTAINING THE
LOGIC REQUIRED FOR THE DESIRED RESULT, OF COURSE!).

     EACH CR-GROUP MUST BE TERMINATED WITH AN 'ENDO' STATEMENT
OR AN 'ELSE' - 'ENDELSE' COMBINATION:

          ENDIF ,
                 - OR -
          ELSE  ,
     ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS
          ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')

     ALTERNATIVELY, A CR-GROUP CAN BE TERMINATED AS FOLLOWS:

          ELSEIF  (CLC,G,H,E),THENDO ...
            ...
          ELSEIF  (CLC,I,J,E),THENDO ...
            ...
          ELSE  ,
            ...
          ENDELSE ,

     ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL
     'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY
     ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE
     GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.

THE 'ELSEIF' IS THE AUTHOR'S CURRENT FEEBLE ATTEMPT AT PROVIDING THE
FUNCTIONALITY OF THE 'CASE' (C/C++) OR 'EVALUATE' (COBOL).

THENDO
THE SIMPLIST OF THESE IS THE 'THENDO' MACRO THAT MUST BE TERMINATED BY
AN 'ENDO':
         CLC   FIELDA,FIELDB
         THENDO E
         ...
         ENDO

THE STATEMENTS REPRESENTED BY THE '...' WILL BE EXECUTED ONLY IF THE
'CLC' RESULTED IN AN 'E'. OPTIONALLY YOU MAY CODE AN 'ELSE' STATEMENT,
AND/OR ONE OR MORE 'ELSEDO' STATEMENTS:

         TRT   FIELDA,TABLE1
         THENDO L       DO IF NON-ZERO FUNCTION AND NOT LAST ARG
         ...
         ELSEDO H       DO IF NON-ZERO FUNCTION AND LAST ARG
         ...
         ELSEDO E       DO IF ALL FUNCTION BYTES ZERO
         ...
         ENDO

SINCE THE 'TRT' CAN ONLY GENERATE CC'S OF 0, 1, OR 2, THAT LAST
'ELSEDO E' COULD HAVE BEEN REPLACED BY 'ELSE'.  AT ANY RATE, THIS IS
A VIABLE WAY TO TEST VALUES OF THE CONDITION CODE THAT ARE SET BY ONE
INSTRUCTION.  AS YOU WILL SEE WITH THE 'IF' STATEMENT, THE
INSTRUCTION(S) THAT SET THE CC AND THE TEST FOR THE VALUE OF THE CC
ALL FORM PART OF THE SAME STATEMENT, SO THAT IT IS PROBABLY BETTER
TO USE THE 'IF' AND 'ELSEIF' WITH INSTRUCTIONS THAT DO NOT MODIFY THEIR
OPERANDS (SUCH AS 'CLC' OR 'TM' ETC.).

EACH CR-GROUP MUST BE HEADED BY ONE OF THE FOLLOWING MACRO STATEMENTS:

  AFTER      DO     EVERY      FIRST      IF        THENDO

AND MUST BE TERMINATED BY ONE OF THE FOLLOWING:

  ENDAFTER   ENDO   ENDEVERY   ENDFIRST   ENDIF

IT IS SOMEWHAT OVERSIMPLIFYING TO SAY THAT ALL OF THE ENDXXXXX MACROS
SIMPLY INVOKE 'ENDO', BUT THE TRUTH IS THAT THE INDIVIDUAL ENDXXXXX
MACROS ARE MORE FOR PROGRAM DOCUMENTATION THAN THEY ARE FOR INTERNAL
LOGIC DIFFERENCES. SO, IF YOU END AN CR-GROUP WITH AN 'ENDAFTER'
MACRO, NO DIAGNOSTICS WILL BE ISSUED AND YOUR PROGRAM WILL WORK THE
SAME AS IF YOU HAD CODED AN 'ENDIF'.

CR-GROUPS MAY BE NESTED TO ANY DESIRED LEVEL:

          IF    ...
          ...
            DO    ...
            ...
            ENDO  ,
          ...
          ENDIF ,

YOU MAY FIND IT EFFECTIVE TO INDENT AT EACH LEVEL OF NESTING, BUT
BEWARE - THE CONTINUATION COLUMN IS ALWAYS THE SAME (16 IS THE
DEFAULT).

THERE ARE TWO ADDITIONAL SIGNIFICANT MACROS THAT CAN BE USED WITHIN
THIS PACKAGE OF STRUCTURED PROGRAMMING MACROS.  THE 'ELSEIF' MACRO CAN
BE USED FOLLOWING AN 'IF' OR ANOTHER 'ELSEIF' MACRO, AND SUPPORTS THE
SAME TYPES OF LOGIC THAT THE 'IF' MACRO SUPPORTS.  THE 'ELSE' MACRO
CAN FOLLOW AN 'IF', 'ELSEIF', 'AFTER', 'EVERY' OR 'FIRST' MACRO, AND
ALLOWS ITS CR-GROUP TO BE EXECUTED IF ALL OF THE PRECEDING CR-GROUPS
WERE NOT EXECUTED.

IN GENERAL, I WOULD SUGGEST THAT YOU NOT CREATE A NAME FIELD FOR A MACRO
THAT ENDS A CR-GROUP. IT MIGHT BE PERMISSIBLE IF YOU NEED TO EXIT THE
CR-GROUP FROM SOMEWHERE DEEP INSIDE IT, BUT AS SOON AS YOU START NAMING
STATEMENTS, IT SIGNALS EVEN MORE BAD HABITS TO COME.

AFTER
THIS MACRO HEADS A CR-GROUP THAT WILL BE SKIPPED FOR THE FIRST 'N'
PASSES THROUGH THIS SECTION OF CODE, AND THEN EXECUTED EVERY PASS
THROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING
TERM. AN 'ELSE' CLAUSE IS OPTIONAL. SEE ALSO 'EVERY' AND 'FIRST'.

 <NAME>  AFTER 1000000
            ...
         ENDAFTER ,

DO
THIS ONE PROVIDES REPETITIVE EXECUTION OF A CR-GROUP. THERE ARE
SEVERAL OPTIONS: THE FIRST IS TO CODE A NUMERIC SELF-DEFINING TERM,
WHICH CAUSES THE CR-GROUP TO BE EXECUTED THAT NUMBER OF TIMES:

 <NAME>   DO    5
            ...
          ENDO  ,

A SLIGHT VARIATION IS TO CODE:

 <NAME>  DO    FOREVER
           ...
         ENDO  ,

THIS CAUSES THE CR-GROUP TO BE CONTINUOUSLY EXECUTED UNTIL SOMETHING
EITHER WITHIN THE LOOP OR SOMETHING OUTSIDE THE PROGRAM (TIME
EXCEEDED, ETC) CAUSES THE LOOP TO BE BROKEN.

IF YOU CODE:

 <NAME>  DO    MYVARBL
           ...
         ENDO  ,

THEN 'MYVARBL' MUST BE A PACKED DECIMAL VARIABLE WHICH YOU HAVE
ALREADY INITIALIZED TO THE VALUE FOR THE NUMBER OF TIMES THAT YOU
WANT THIS CR-GROUP REPEATED. BE VERY CAREFUL ABOUT MODIFYING THIS
VARIABLE FROM WITHIN THE LOOP. ITS VALUE IS CAPTURED ONLY AT THE
BEGINNING OF THE EXECUTION OF THE CR-GROUP, AND ANY CHANGE TO THE
VALUE OF THE VARIABLE WILL TAKE EFFECT THE NEXT TIME THE 'DO'
STATEMENT IS ENCOUNTERED.

IF YOU WANT TO REPEAT A CR-GROUP BASED ON ONE OR MORE CONDITIONS,
THEN YOU CAN USE EITHER ONE OF THE FOLLOWING:

 <NAME>  DO    UNTIL=(...)
           ...
         ENDO  ,

         .. OR ..

 <NAME>  DO    WHILE=(...)
           ...
         ENDO  ,

IN THE FIRST OF THESE TWO EXAMPLES, THE CR-GROUP WILL BE EXECUTED
REPETITIVELY UNTIL ONE OR MORE OF THE CONDITIONS IS MET. IN THE
SECOND, IT WILL BE EXECUTED SO LONG AS ONE OR MORE OF THE CONDITIONS
IS MET.  IN BOTH OF THESE EXAMPLES, THE VALUES WITHIN THE PARENTHESES
ARE THE SAME AS FOR THE 'IF' MACRO. PLEASE SEE ITS DOCUMENTATION FOR
THE DETAILS.  THE ONLY DIFFERENCE BETWEEN THE OPERANDS HERE AND FOR
THE 'IF' MACRO IS THAT, IF THE CONDITION IS COMPLEX, THAT IS, IF IT
CONSISTS OF MULTIPLE CONDITIONS CONNECTED WITH 'AND' AND/OR 'OR'
CLAUSES, THEN THE ENTIRE OPERAND MUST BE ENCLOSED WITHIN ONE
ADDITIONAL LEVEL OF PARENTHESES:

 <NAME>   DO    UNTIL=((...),OR,(...))
                      *              *  <== REQUIRED IF COMPLEX
            ...
          ENDO  ,

ONE ADDITIONAL KEYWORD OPERAND IS AVAILABLE:

 <NAME>   DO    UNTIL=(...),TEST=AFTER
            ...
          ENDO  ,

          .. OR ..

 <NAME>   DO    WHILE=(...),TEST=AFTER
            ...
          ENDO  ,

THE 'TEST=AFTER' CAUSES THE CR-GROUP TO BE EXECUTED ONE TIME BEFORE
THE CONDITIONAL TESTS ARE MADE. DEFAULT IS 'TEST=BEFORE', WHERE THE
CR-GROUP MIGHT NOT BE EXECUTED EVEN ONCE, DEPENDING ON THE INITIAL
CONDITIONS.

DOEXIT
THE 'DOEXIT' MACRO CAUSES EXECUTION TO TRANSFER TO THE FIRST INSTRUCTION
FOLLOWING THE MATCHING 'ENDO' STATEMENT:

 <NAME>   DO    UNTIL=(...)
            ...
            DOEXIT ,
            ...
          ENDO  ,

IF THERE IS NESTED LOGIC CONSISTING OF 'IF' STATEMENTS AND 'DO'
STATEMENTS, A 'DOEXIT' STATEMENT ALWAYS TRANSFERS CONTROL TO THE
STATEMENT FOLLOWING THE INNERMOST 'DO' STATEMENT:

<NAME>    DO    UNTIL=(...)
            ...
            IF    (...),THENDO
              ...
              DOEXIT , TRANSFERS TO STATEMENT FOLLOWING .. |
              ...                                          |
              DO    WHILE=(...)                            |
                ...                                        |
                DOEXIT , TRANSFERS TO STMT FOLLOWING |     |
                ...                                  |     |
              ENDO  ,                 <---------------     |
              ...                                          |
            ENDIF ,                                        |
            ...                                            |
          ENDO  ,                     <---------------------

DONEXT
THE 'DONEXT' MACRO TRANSFERS EXECUTION TO THE LOGIC CONTROLLING THE DO
STATEMENT FOR THE NEXT ITERATION. DEPENDING ON THE CONDITIONS BEING
TESTED, THE CR-GROUP MIGHT OR MIGHT NOT BE EXECUTED AGAIN.

 <NAME>   DO    UNTIL=(...)
            ...
            DONEXT ,
            ...
          ENDO  ,

IF THERE IS NESTED LOGIC CONSISTING OF 'IF' STATEMENTS AND 'DO'
STATEMENTS, A 'DONEXT' STATEMENT ALWAYS TRANSFERS CONTROL TO THE
STATEMENT FOLLOWING THE INNERMOST 'DO' STATEMENT:

<NAME>    DO    UNTIL=(...)
            ...
            IF    (...),THENDO
              ...
              DONEXT , TRANSFERS TO STATEMENT FOLLOWING .. |
              ...                                          |
              DO    WHILE=(...)                            |
                ...                                        |
                DONEXT , TRANSFERS TO STMT FOLLOWING |     |
                ...                                  |     |
              ENDO  ,                 <---------------     |
              ...                                          |
            ENDIF ,                                        |
            ...                                            |
          ENDO  ,                     <---------------------

ELSE
THIS MACRO MAY BE CODED ONLY WITHIN A CR-GROUP HEADED BY AN 'AFTER',
'ELSEIF', 'EVERY' OR 'FIRST' CR-GROUP HEADER.  IT CAUSES EXECUTION OF
ITS CR-GROUP IF ALL OF THE PREVIOUS CR-GROUPS HAVE BEEN BYPASSED:

 <NAME>   AFTER 1000000
            ...             EXECUTED AFTER 1,000,000 PASSES
          ELSE  ,
            ...             EXECUTED FIRST 1,000,000 PASSES
          ENDELSE ,

ELSEIF
THIS MACRO MAY FOLLOW ONLY ANOTHER 'ELSEIF' STATEMENT, OR AN 'IF'
STATEMENT. IT SUPPORTS ALL THE OPTIONS OF THE 'IF' STATEMENT. PLEASE
SEE THE 'IF' STATEMENT FOR THE DETAILS.

 <NAME>   IF    (...),THENDO
            ...
          ELSEIF (...),THENDO
            ...
          ENDELSE ,

ENDAFTER
ENDELSE
ENDEVERY
ENDFIRST
ENDIF
ENDO

THESE MACROS ARE EQUIVALENT, AND SHOULD BE USED TO END THEIR
RESPECTIVE TYPES OF CR-GROUPS. THE ONE 'INTERESTING' PARAMETER IS THE
'DOGROUP=' KEYWORD.  IF YOU NAMED A PREVIOUS CR-GROUP HEADER MACRO (SUCH
AS 'IF' OR 'DO'), AND YOU HAVE NESTED CR-GROUPS, THEN YOU MAY TERMINATE
MULTIPLE CR-GROUPS WITH ONE 'ENDO' MACRO BY NAMING THE OUTERMOST GROUP
THAT YOU WANT TO TERMINATE, AND THEN NAMING THAT GROUP ON THE 'ENDO'
MACRO:

 MAINGRP IF    (...),THENDO
           ...
           IF    (...),THENDO
             ...
         ENDIF DOGROUP=MAINGRP

IF YOU WANT TO TERMINATE ALL CR-GROUPS, THEN CODE THE 'MAGIC' KEYWORD:

 MAINGRP IF    (...),THENDO
           ...
           IF    (...),THENDO
             ...
         ENDIF DOGROUP=*ALL*

SINCE '*ALL*' IS NOT A VALID ASSEMBLER TAG, IT CAN BE SAFELY USED AS
THE FLAG TO INDICATE THAT ALL CURRENT CR-GROUPS ARE TO BE TERMINATED.

EVERY
THIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED EVERY 'N'TH PASS
THROUGH THIS SECTION OF CODE. 'N' MUST BE A NUMERIC SELF-DEFINING TERM.
AN 'ELSE' CLAUSE IS OPTIONAL. SEE ALSO 'AFTER' AND 'FIRST'.

 <NAME>  EVERY 1000000
            WTO   'ANOTHER 1,000,000 PASSES'
         ENDEVERY ,

FIRST
THIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED FOR THE FIRST 'N'
PASSES THROUGH THIS SECTION OF CODE, AND THEN SKIPPED EVERY PASS
THROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING
TERM. AN 'ELSE' CLAUSE IS OPTIONAL. SEE ALSO 'AFTER' AND 'FIRST'.

 <NAME>  FIRST 1000000
            ...
         ENDAFTER ,

ITS DESIGNED USE IS TO DO STUFF ONLY ON THE FIRST PASS THROUGH A
SECTION OF CODE

 <NAME>  FIRST 1
           OPEN  (...)
         ENDFIRST ,

THENDO
THIS WAS THE ORIGINAL STRUCTURED MACRO OF THIS PACKAGE.  IT IS NOT SO
POWERFUL AS THE NEWER ONES, BUT YOU MIGHT FIND SOME USE FOR IT. ITS ONLY
POSITIONAL PARAMETER MUST BE ONE OF THE CONDITIONS THAT YOU CAN APPEND
TO THE 'B' TO CREATE ONE OF THE EXTENDED BRANCH INSTRUCTIONS, SUCH AS
'E'.  PLEASE REFER TO THE DOCUMENTATION FOR THE 'IF' MACRO FOR A
COMPLETE LIST.

THIS MACRO DEPENDS ON A PREVIOUS INSTRUCTION IN THE PROGRAM, SUCH AS A
'CLR', TO SET THE CONDITION CODE. ITS CR-GROUP WILL THEN BE EXECUTED IF
THE OPERAND SATISFIES THE SETTING OF THE CONDITION CODE:

          CLR   R5,R6
 <NAME>   THENDO E
            ...
          ENDO  ,

          -- OR --

          CLC   R5,R6
 <NAME>   THENDO E
            ...
          ELSE  ,
            ...
          ENDO  ,

IN THIS EXAMPLE, THE FIRST CR-GROUP WILL BE EXECUTED IF R5 = R6, AND
THE SECOND WILL BE EXECUTED IF THEY ARE UNEQUAL.

THAT'S IT, FOLKS. NO OTHER OPTIONS FOR 'THENDO' (OTHER THAN NESTING).
./ ADD NAME=DOEXIT   0107-02015-02016-0915-00014-00013-00000-GENTR02
         MACRO
&NAME    DOEXIT &DUMMY             XFER OUT OF INNERMOST DO-GROUP
         COPY  $MGBLDEF            BRING IN THE CLOWNS
         LCLA  &I                  LOCAL INTEGER VARIABLE
&I       SETA  &$MDGLVL            START AT CURRENT NESTING LEVEL
.LOOP010 AIF   (&I GT 0).CONT020   CONTINUE IF NOT ALL DONE
         MNOTE 8,'NO DO-GROUP TO EXIT FROM' OOPS...
         AGO   .MEND040            ALL WAS FOR NAUGHT
.CONT020 AIF   ('&$MCVERB(&I)' EQ 'DO').GEN030 IS THIS LEVEL A 'DO'?
&I       SETA  &I-1                NO - BACK UP TO NEXT OUTER LEVEL
         AGO   .LOOP010            PROCESS NEXT OUTER GROUP
.GEN030  ANOP  ,                   DANG, GOT A LIVE ONE!
&NAME    J     $MDF&$MDGSEQ(&I)    B TO INSTRUCTION FOLLOWING 'ENDO'
.MEND040 MEND
./ ADD NAME=DONEXT   0100-02028-02028-0854-00014-00014-00000-GENTR02
         MACRO
&NAME    DONEXT &DUMMY
         COPY  $MGBLDEF
         LCLA  &I                  LOCAL INTEGER VARIABLE
&I       SETA  &$MDGLVL            START AT CURRENT NESTING LEVEL
.LOOP010 AIF   (&I GT 0).CONT020   CONTINUE IF NOT ALL DONE
         MNOTE 8,'NO DO-GROUP TO DO NEXT ITERATION' OOPS...
         AGO   .MEND040            ALL WAS FOR NAUGHT
.CONT020 AIF   ('&$MCVERB(&I)' EQ 'DO').GEN030 IS THIS LEVEL A 'DO'?
&I       SETA  &I-1                NO - BACK UP TO NEXT OUTER LEVEL
         AGO   .LOOP010            PROCESS NEXT OUTER GROUP
.GEN030  ANOP  ,                   DANG, GOT A LIVE ONE!
&NAME    J     &$MLTAG(&I)         RETURN TO 'DO' CONTROL
.MEND040 MEND
./ ADD NAME=ELSE     0109-02015-02067-1609-00028-00027-00000-GENTR02
         MACRO
&NAME    ELSE  &DOGROUP=,&MNAME=ELSE  END OF POSITIVE TEST, START OF
         COPY  $MGBLDEF            . NEGATIVE
         LCLC  &X                  SET TO 'IF-FAILED' TAG
         AIF   (&$MDGLVL GT 0).OK02
         MNOTE 8,'''&MNAME'' IS VALID ONLY WITHIN AN IF-GROUP'
         MNOTE 0,' - MACRO GENERATION TERMINATED'
         MEXIT
.OK02    $MENDDO1 DOGROUP=&DOGROUP
         AIF   (&$MDGERR NE 0).QUIT GIVE UP IF ERROR
         AIF  ('&$MLTAG(&$MDGLVL)' EQ '').SKIP30
         MNOTE 8,'''&MNAME'' INVALID FOR ''DO'' - ENDO ASSUMED'
         $MENDDO2 ,                PRETEND NO 'ELSEDO'
         MEXIT
.SKIP30  AIF   ('&$MIFELS(&$MDGLVL)' NE 'S').SKIP40
         MNOTE 8,'''&MNAME'' INVALID FOLLOWING ''&MNAME'' -'
         MNOTE '''ENDO'' INVOKED'
         $MENDDO2                 JUST LIKE NO 'ELSEDO'
         MEXIT
.SKIP40  J     $MDS&$MDGSEQ(&$MDGLVL) BRANCH AROUND ELSE-GROUP
&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' 'IF-FAILED' TAG
         AIF   ('&NAME' EQ '').SKIP50
&NAME    DC    0H'0'         *=*=* BEGINNING OF 'ELSE' GROUP *=*=*
.SKIP50  ANOP
&X       DC    0H'0'         *=*=* BEGINNING OF 'ELSE' GROUP *=*=*
&$MIFELS(&$MDGLVL) SETC 'S'
&$MCVVERB(&$MDGLVL) SETC '&$MCVVERB(&$MDGLVL).ELSE'
.QUIT    MEND
./ ADD NAME=ELSEDO   0116-01222-02067-1610-00029-00035-00000-GENTR02
         MACRO
&NAME    ELSEDO &COND
         COPY  $MGBLDEF
         LCLC  &X
         AIF   (&$MDGLVL GT 0).OK02
         MNOTE 8,'''ELSEDO'' IS VALID ONLY WITHIN A THENDO-GROUP'
         MNOTE 0,' - MACRO GENERATION TERMINATED'
         MEXIT
.OK02    AIF   ('&$MIFELS(&$MDGLVL)' EQ 'F').OK04
         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''ELSE'' STATEMENT'
         MNOTE 0,' - MACRO GENERATION TERMINATED'
         MEXIT
.OK04    AIF   ('&$MLTAG(&$MDGLVL)' EQ '').OK20
         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''DO'' STATEMENT'
         MNOTE 0,' - MACRO GENERATION TERMINATED'
         MEXIT
.OK20    AIF   ('&$MFNBR(&$MDGLVL)' NE '').OK30
         $MGFNBR  ,                GET A UNIQUE TAG
.OK30    J     $MDF&$MFNBR(&$MDGLVL) BRANCH AROUND IF-GROUP
&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)'
         AIF   ('&NAME' EQ '').SKIP40
&NAME    DC    0H'0'               DEFINE TAG
.SKIP40  ANOP
&X       DC    0H'0'               TAG FOR 'ELSE'
&X       SETC  '&$MDGNAM(&$MDGLVL)'
&$MDGLVL SETA  &$MDGLVL-1          SO 'THENDO' CAN BUMP IT UP AGAIN
         THENDO &COND
&$MDGNAM(&$MDGLVL) SETC '&X'
         MEND
./ ADD NAME=ELSEIF   0110-01222-02067-1610-00036-00035-00000-GENTR02
         MACRO
&NAME    ELSEIF &EXP
         COPY  $MGBLDEF
         LCLC  &X
         AIF   (&$MDGLVL GT 0).OK02
         MNOTE 12,'''ELSEIF'' IS VALID ONLY WITHIN AN IF-GROUP - MACRO C
               GENERATION TERMINATED'
         MEXIT
.OK02    AIF   ('&$MIFELS(&$MDGLVL)' EQ 'F').OK04
         MNOTE 12,'''ELSEIF'' INVALID FOLLOWING ''ELSE'' STATEMENT - MAC
               CRO GENERATION TERMINATED'
         MEXIT
.OK04    AIF   ('&$MLTAG(&$MDGLVL)' EQ '').OK20
         MNOTE 12,'''ELSEIF'' INVALID FOLLOWING ''DO'' STATEMENT - MACRC
               O GENERATION TERMINATED'
         MEXIT
.OK20    AIF   ('&$MFNBR(&$MDGLVL)' NE '').OK30
         $MGFNBR  ,                GET A UNIQUE TAG
.OK30    J     $MDF&$MFNBR(&$MDGLVL) BRANCH AROUND ELSEIF-GROUP
&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)'
&$MDGLVL SETA  &$MDGLVL-1          SO 'IF' CAN BUMP IT UP AGAIN
         $MLVLMSG &$MDGLVL,NESTING
         AIF   ('&NAME' EQ '').SKIP40
&NAME    DC    0H'0'         *=*=* BEGINNING OF 'ELSEIF' GROUP *=*=*
.SKIP40  ANOP
&X       IF    &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),        C
               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        C
               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     C
               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16),    C
               &SYSLIST(17),&SYSLIST(18),&SYSLIST(19),&SYSLIST(20),    C
               &SYSLIST(21),&SYSLIST(22),&SYSLIST(23),&SYSLIST(24),    C
               &SYSLIST(25),&SYSLIST(26),&SYSLIST(27),&SYSLIST(28),    C
               &SYSLIST(29),&SYSLIST(30),&SYSLIST(31),&SYSLIST(32)
&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET NAME FOR 'ENDIF'
&$MCVERB(&$MDGLVL) SETC 'ELSEIF'   SET NAME FOR 'ENDIF'
         MEND
./ ADD NAME=ENDAFTER 0104-02015-02067-1610-00018-00017-00000-GENTR02
         MACRO
&NAME    ENDAFTER &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT
         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE
         AIF   (&$MDGLVL GT 0).OK02
         MNOTE 8,'''ENDAFTER'' INVALID OUTSIDE DO-GROUP'
         MNOTE 0,' - MACRO GENERATION TERMINATED'
         MEXIT
.OK02    ANOP
         LCLC  &X
&X       SETC  '&$MCVERB(&$MDGLVL)'
         AIF   ('&X' EQ 'AFTER').CONT010
         AIF   ('&X' EQ 'AFTERELSE').CONT010
         MNOTE 4,'''ENDAFTER'' USED TO TERMINATE ''&X'' GROUP'
.CONT010 ANOP  ,
&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL
         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY
         $MENDDO2                  END FINAL LEVEL
.QUIT    MEND
./ ADD NAME=ENDELSE  0101-02015-02046-1624-00018-00017-00000-GENTR02
         MACRO
&NAME    ENDELSE &DOGROUP=         INTERCHANGEABLE WITH 'ENDO' EXCEPT
         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE
         AIF   (&$MDGLVL GT 0).OK02
         MNOTE 8,'''ENDELSE'' INVALID OUTSIDE DO-GROUP'
         MNOTE 0,' - MACRO GENERATION TERMINATED'
         MEXIT
.OK02    ANOP
         LCLC  &X
&X       SETC  '&$MCVERB(&$MDGLVL)'
         AIF   ('&X' EQ 'ELSE').CONT010
         AIF   ('&X' EQ 'ELSEIF').CONT010
         MNOTE 4,'''ENDELSE'' USED TO TERMINATE ''&X'' GROUP'
.CONT010 ANOP  ,
&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL
         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY
         $MENDDO2                  END FINAL LEVEL
.QUIT    MEND
./ ADD NAME=ENDEVERY 0104-02015-02067-1611-00018-00017-00000-GENTR02
         MACRO
&NAME    ENDEVERY &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT
         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE
         AIF   (&$MDGLVL GT 0).OK02
         MNOTE 8,'''ENDEVERY'' INVALID OUTSIDE DO-GROUP'
         MNOTE 0,' - MACRO GENERATION TERMINATED'
         MEXIT
.OK02    ANOP
         LCLC  &X
&X       SETC  '&$MCVERB(&$MDGLVL)'
         AIF   ('&X' EQ 'EVERY').CONT010
         AIF   ('&X' EQ 'EVERYELSE').CONT010
         MNOTE 4,'''ENDEVERY'' USED TO TERMINATE ''&X'' GROUP'
.CONT010 ANOP  ,
&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL
         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY
         $MENDDO2                  END FINAL LEVEL
.QUIT    MEND
./ ADD NAME=ENDFIRST 0104-02015-02067-1611-00018-00017-00000-GENTR02
         MACRO
&NAME    ENDFIRST &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT
         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE
         AIF   (&$MDGLVL GT 0).OK02
         MNOTE 8,'''ENDFIRST'' INVALID OUTSIDE DO-GROUP'
         MNOTE 0,' - MACRO GENERATION TERMINATED'
         MEXIT
.OK02    ANOP
         LCLC  &X
&X       SETC  '&$MCVERB(&$MDGLVL)'
         AIF   ('&X' EQ 'FIRST').CONT010
         AIF   ('&X' EQ 'FIRSTELSE').CONT010
         MNOTE 4,'''ENDFIRST'' USED TO TERMINATE ''&X'' GROUP'
.CONT010 ANOP  ,
&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL
         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY
         $MENDDO2                  END FINAL LEVEL
.QUIT    MEND
./ ADD NAME=ENDIF    0106-02015-02067-1611-00013-00010-00000-GENTR02
         MACRO
&NAME    ENDIF &ELSE,&DOGROUP=
         COPY  $MGBLDEF
         LCLC  &X
&X       SETC  '&$MCVERB(&$MDGLVL)'
         AIF   ('&X' EQ 'IF').CONT010
         AIF   ('&X' EQ 'IFELSE').CONT010
         AIF   ('&X' EQ 'ELSEIF').CONT010
         MNOTE 4,'''ENDIF'' USED TO TERMINATE ''&X'' GROUP'
.CONT010 ANOP  ,
&$MCVERB(&$MDGLVL) SETC 'DO'       FAKE OUT 'ENDO' MACRO
&NAME    ENDO  &ELSE,DOGROUP=&DOGROUP
         MEND
./ ADD NAME=ENDO     0107-02015-02092-1009-00038-00034-00000-GENTR02
         MACRO
&NAME    ENDO  &ELSE,&DOGROUP=    INTERCHANGEABLE WITH 'ENDELSE' EXCEPT
         COPY  $MGBLDEF           . FOR 'ENDELSE' CLAUSE
         LCLC  &X                  SET TO 'IF-FAILED' TAG
         AIF   (&$MDGLVL GT 0).OK02
         MNOTE 8,'''ENDO'' INVALID OUTSIDE DO-GROUP - MACRO GENERATION C
               TERMINATED'
         MEXIT
.OK02    ANOP
&X       SETC  '&$MCVERB(&$MDGLVL)'
         AIF   ('&X' EQ 'DO').OK03
         MNOTE 4,'''ENDO'' USED TO TERMINATE ''&X'' GROUP'
.OK03    ANOP  ,
&NAME    $MENDDO1 DOGROUP=&DOGROUP
         AIF   (&$MDGERR NE 0).QUIT GIVE UP IF ERROR
         AIF   ('&ELSE' NE '').NEXT10 NO 'ELSE' - END LAST LEVEL
         $MENDDO2                 LAST LEVEL FOR THIS PASS
         MEXIT
.NEXT10  AIF   ('&ELSE' EQ 'ELSEDO').NEXT20 GO IF LEGIT 'ELSEDO'
         MNOTE *,'ERROR IN PARM ''&ELSE'' - PARM IGNORED'
         $MENDDO2                 JUST LIKE NO '&ELSE'
         MEXIT
.NEXT20  ANOP
         AIF  ('&$MLTAG(&$MDGLVL)' EQ '').SKIP30
         MNOTE 8,'''ELSEDO'' INVALID FOR ''DO'' - IGNORED'
         $MENDDO2                 JUST LIKE NO '&ELSE'
         MEXIT
.SKIP30  ANOP
         AIF   ('&$MIFELS(&$MDGLVL)' NE 'S').SKIP40
         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''ELSEDO'' - ''ENDO'' INC
               VOKED'
         $MENDDO2                 JUST LIKE NO 'ELSEDO'
         MEXIT
.SKIP40  J     $MDS&$MDGSEQ(&$MDGLVL) BRANCH AROUND ELSE-GROUP
&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' 'IF-FAILED' TAG
&X       DC    0H'0'              TAG FOR 'IF' FAILURE
&$MIFELS(&$MDGLVL) SETC 'S'       SET FOR 'ENDELSE'
.QUIT    MEND
./ ADD NAME=ENDTEST
         MACRO
&NAME    ENDTEST &DUMMY
         AIF   ('&NAME' EQ '').MEND999
&NAME    DS    0H                  TAG GENERATED BY 'ENDTEST' MACRO
.MEND999 MEND
./ ADD NAME=EQUATE   0101-02067-02067-1444-00011-00008-00000-GENTR02
         MACRO
         EQUATE
         PUSH  PRINT               *=*=*=*=*=*=*=*=*=*=*=*=*=*=*
         PRINT NOGEN               *=* HIDE REGISTER EQUATES *=*
&I       SETA  0
.LOOP010 ANOP
R&I      EQU   &I
&I       SETA  &I+1
         AIF   (&I LT 16).LOOP010
         POP   PRINT               *=*=*=*=*=*=*=*=*=*=*=*=*=*=*
         MEND
./ ADD NAME=EVERY    0113-01331-02070-1321-00023-00024-00000-GENTR02
         MACRO
&NAME    EVERY &VAR
         COPY  $MGBLDEF            BRING IN THE CLOWNS
&LCLV    SETC  '&VAR'              SET TO COUNT
         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING
         MNOTE 8,'''&VAR'' NOT SELF-DEFINING: 'EVERY' GROUP WILL BE PROC
               CESSED EACH PASS THROUGH THIS SECTION OF CODE'
&LCLV    SETC  '1'                 DO EVERY TIME
.OK30    ANOP
&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL
         $MLVLMSG &$MDGLVL,NESTING
&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'
&$MIFELS(&$MDGLVL) SETC 'F'
&$MDGNAM(&$MDGLVL) SETC '&NAME'
&$MCVERB(&$MDGLVL) SETC 'EVERY'
&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY
&NAME    SP    &X,=P'1'            DECREMENT
         JP    $MDF&SYSNDX         B IF NOT YET TIME
         MVC   &X,=P'&LCLV'        RESET
&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA
&X       DC    P'&LCLV'            FREQUENCY COUNTER
&SYSECT  LOCTR                     RESUME INSTRUCTION AREA
         MEND
./ ADD NAME=EXECUTE  0112-01236-02078-1624-00015-00024-00000-GENTR02
         MACRO
&N       EXECUTE &DUMMY            OPERANDS ACCESSED VIA &SYSLIST(N)
         COPY  $MGBLDEF            GET STANDARD NAME FOR LOCTR
         LCLC  &TEMP,&X,&OP        LOCAL SCRATCHPAD VARIABLES
&X       SETC  '&SYSNDX'           FOR UNIQUENESS
&N       EX    &SYSLIST(1),$EX&X   DO THE 'EX'ECUTE
&TEMP    SETC  ','                 THIS WILL ALWAYS WORK
         AIF   (K'&SYSLIST(3) LT 3).CONT010 GO IF ZERO OPERANDS
&TEMP    SETC  '&SYSLIST(3)'(2,K'&SYSLIST(3)-2) FAILS IF ZERO OPERANDS
.CONT010 ANOP
&OP      SETC  '&SYSLIST(2)'       FOR BREVITY
&$MLOCTR LOCTR ,                   OUT-OF-LINE STORAGE AREA
$EX&X    &OP   &TEMP               'EX'ECUTED INSTRUCTION
&SYSECT  LOCTR ,                   INSTRUCTION AREA
         MEND
./ ADD NAME=FIRST    0115-01331-02070-1324-00033-00034-00000-GENTR02
         MACRO
&NAME    FIRST &VAR
         COPY  $MGBLDEF            BRING IN THE CLOWNS
&LCLV    SETC  '&VAR'              SET TO COUNT
         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING
         MNOTE 8,'''&VAR'' NOT SELF-DEFINING: 'FIRST' GROUP WILL BE PROC
               CESSED ONLY THE FIRST TIME THROUGH THIS SECTION OF CODE'
&LCLV    SETC  '1'                 DO EVERY TIME
.OK30    ANOP
&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL
         $MLVLMSG &$MDGLVL,NESTING
&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'
&$MIFELS(&$MDGLVL) SETC 'F'
&$MDGNAM(&$MDGLVL) SETC '&NAME'
&$MCVERB(&$MDGLVL) SETC 'FIRST'
&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY
         AIF   ('&LCLV' NE '1').SKIP030
&NAME    TM    &X,X'01'            HAVE WE BEEN HERE BEFORE?
         JO    $MDF&SYSNDX         B IF YES
         OI    &X,X'01'            LEAVE TRACKS
&$MLOCTR LOCTR                     ENTER WORK AREA
&X       DC    X'00'               SET TO X'01' FIRST PASS
&SYSECT  LOCTR                     RESUME INSTRUCTION AREA
         MEXIT
.SKIP030 ANOP
&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY
&NAME    CP    &X,=P'0'            FINISHED?
         JNH   $MDF&SYSNDX         B IF YES
         SP    &X,=P'1'            DECREMENT BY 1
&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA
&X       DC    P'&LCLV'            EXECUTION TIMES COUNTER
&SYSECT  LOCTR                     RESUME INSTRUCTION AREA
         MEND
./ ADD NAME=IF       0126-02052-02102-1631-00155-00149-00000-GENTR02
         MACRO
&NAME    IF    &EXP                MULTIPLE OPERANDS VIA &SYSLIST
         COPY  $MGBLDEF            BRING IN GLOBAL SET SYMBOLS
         LCLA  &I,&J,&K            USED TO SCAN &SYSLIST OPERANDS, ETC
         LCLC  &X,&Y,&OP,&OPND1,&OPND2,&OPND3,&C,&NC
&$MRECUR SETA  &$MRECUR+1          INCREASE RECURSION COUNT
         $MLVLMSG &$MRECUR,RECURSION CONDITIONALLY ISSUE MESSAGE
&I       SETA  1                   SET TO FIRST POSITIONAL
&$MNAME  SETC  '&NAME'             TAG FOR FIRST TEST
.LOOP010 AIF   (N'&SYSLIST LT &I).FIN180 GO TO FINISH IF DONE
         AIF   ('&SYSLIST(&I)'(1,1) NE '(').BADC120 MUST BE '('
         AIF   ('&SYSLIST(&I)'(2,1) EQ '(').REC080 GO IF NESTED
&OP      SETC  '&SYSLIST(&I,1)'    OP-CODE IS ALWAYS 1ST SUB-OPERAND
&J       SETA  N'&SYSLIST(&I)      NUMBER OF SUBPARAMETERS FOR THIS ONE
         AIF   (&J NE 2).TEST020   GO TEST FOR 1-OPERAND INST
&$MNAME  &OP   ,                   ZERO OPERANDS - SET CONDITION CODE
&$MC     SETC  '&SYSLIST(&I,2)'    CONDITION IS ALWAYS LAST SUB-OPERAND
         AGO   .FING060            GO SET UP BRANCH INST
.TEST020 ANOP  ,
&OPND1   SETC  '&SYSLIST(&I,2)'    FIRST (ONLY?) OPERAND
         AIF   (&J NE 3).TEST030   GO TEST FOR 2-OPERAND INST
&$MNAME  &OP   &OPND1        ONE OPERAND - SET CONDITION CODE
&$MC     SETC  '&SYSLIST(&I,3)'    CONDITION IS ALWAYS LAST SUB-OPERAND
         AGO   .FING060            GO SET UP BRANCH INST
.TEST030 ANOP  ,
&OPND2   SETC  '&SYSLIST(&I,3)'    SECOND OPERAND
         AIF   (&J NE 4).TEST040   GO TEST FOR 3-OPERAND INST
&$MNAME  &OP   &OPND1,&OPND2 TWO OPERANDS - SET CONDITION CODE
&$MC     SETC  '&SYSLIST(&I,4)'    CONDITION IS ALWAYS LAST SUB-OPERAND
         AGO   .FING060            GO SET UP BRANCH INST
.TEST040 ANOP  ,
&OPND3   SETC  '&SYSLIST(&I,4)'    THIRD OPERAND
         AIF   (&J NE 5).ERR050    GO ISSUE ERROR MESSAGE
&$MNAME  &OP   &OPND1,&OPND2,&OPND3 THREE OPERANDS - SET CONDITION CODE
&$MC     SETC  '&SYSLIST(&I,5)'    CONDITION IS ALWAYS LAST SUB-OPERAND
         AGO   .FING060            GO SET UP BRANCH INST
.ERR050  ANOP  ,
&K       SETA  ((&I+1)/2)          GET SEQUENCE # OF PHRASE IN ERROR
         MNOTE 08,'INVALID NUMBER OF PARMS (&J) IN CONDITIONAL PHRASE #*
               &K &SYSLIST(&I); IT WILL BE OMITTED FROM THE MACRO EXPAN*
               SION'
&$MAXRC  SETA  8
&$MNAME  CLC   *(1),*              PLACE HOLDER
&$MNAME  SETC  ''                  NO DUPES
         JNOP  *                   PLACE HOLDER
&I       SETA  &I+2                INCREMENT
         AGO   .LOOP010            BACK FOR MORE
.FING060 ANOP                      COND CODE NOW SET - TEST IT
&$MNAME  SETC  ''                  C'MON - NO DUPLICATE TAGS, PLEASE
&$MNC    SETC  'N&$MC'             SET TO 'NOT'-CONDITION CODE
         AIF   ('&$MC'(1,1) NE 'N').SKIP070 FALL THROUGH IF 'NE' ETC
&$MNC    SETC  '&$MC'(2,1)         ORIG WAS 'NX' - SET TO 'X'
.SKIP070 ANOP                       EXAMPLE 'NE' - SET TO 'E'
         AIF   ('&SYSLIST(&I+2)' EQ '').FIN180 GO IF END OF STATEMENT
         AIF   ('&SYSLIST(&I+1)' EQ 'OR').OR130 GO IF 'OR'
         AIF   ('&SYSLIST(&I+1)' EQ 'AND').OR130 GO IF 'AND'
         MNOTE 8,'TERM ''&SYSLIST(&I+1)'' ACCEPTED AS AN ''OR'' CLAUSE'
&$MAXRC  SETA  8
         AGO   .OR130              COMMON FOR 'AND' AND 'OR'
.REC080  ANOP                      HERE FOR RECURSIVE CALL
&$MNAME  IF    &SYSLIST(&I,1),&SYSLIST(&I,2),&SYSLIST(&I,3),           C
               &SYSLIST(&I,4),&SYSLIST(&I,5),&SYSLIST(&I,6),           C
               &SYSLIST(&I,7),&SYSLIST(&I,8),&SYSLIST(&I,9),           C
               &SYSLIST(&I,10),&SYSLIST(&I,11),&SYSLIST(&I,12),        C
               &SYSLIST(&I,13),&SYSLIST(&I,14),&SYSLIST(&I,15),        C
               &SYSLIST(&I,16),&SYSLIST(&I,17),&SYSLIST(&I,18),        C
               &SYSLIST(&I,19),&SYSLIST(&I,20),&SYSLIST(&I,21)
         AIF   ('&$MFNAM1(&$MRECUR+1)' EQ '').REC100 GO IF NO FNAM1(+1)
         AIF   ('&$MFNAM1(&$MRECUR)' EQ '').REC090 GO IF NO FNAM1
&X       SETC  '&$MFNAM1(&$MRECUR+1)' TEMP FOR FNAM1(+1)
&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY
&X       EQU   &$MFNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC
         AGO   .REC100             TEST PNAM1
.REC090  ANOP
&$MFNAM1(&$MRECUR) SETC '&$MFNAM1(&$MRECUR+1)' PROMOTE
&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY
.REC100  AIF   ('&$MPNAM1(&$MRECUR+1)' EQ '').REC110 GO IF NO PNAM1(+1)
&$MNAME  SETC  '&$MPNAM1(&$MRECUR+1)' QUEUE FOR TEST INSTRUCTION
&$MPNAM1(&$MRECUR+1) SETC ''       NULLIFY
.REC110  AIF   ('&SYSLIST(&I+2)' EQ '').FIN180 GO IF END OF STATEMENT
         AIF   ('&SYSLIST(&I+1)' EQ  'OR').OR130 GO IF 'OR'
         AIF   ('&SYSLIST(&I+1)' EQ 'AND').OR130 GO IF 'AND'
         AGO   .FIN180             NOT 'OR' OR 'AND' - ASSUME END
.BADC120 MNOTE 12,'''&SYSLIST(&I)'' IS NOT A VALID CONDITIONAL PHRASE: C
               EACH CONDITIONAL PHRASE MUST BE ENCLOSED WITHIN ONE OR MC
               ORE PAIRS OF PARENTHESES. MACRO GENERATION ABORTED.'
&$MAXRC  SETA  12
         AGO   .FIN180             GO WRAP IT UP
.OR130   ANOP                      COMMON FOR 'OR' AND 'AND'
&NC      SETC  '&$MNC'             GEN LOCAL VARIABLES FOR
&C       SETC  '&$MC'              . CONDITION CODE TESTS
&$MNC    SETC  ''                  NULLIFY THE GLOBAL VARIABLES
&$MC     SETC  ''                  . SINCE LOCALS WILL BE USED
         AIF   ('&SYSLIST(&I+1)' EQ 'AND').AND160   GO IF 'AND'
         AIF   ('&$MPNAM1(&$MRECUR)' NE '').OR140 SKIP IF NOT NEEDED
         $MGPNAME                  GET A NEW 'PNAM1'
.OR140   J&C   &$MPNAM1(&$MRECUR)  B IF TRUE TO 'PASS' TAG
&I       SETA  &I+2                BUMP TO NEXT OPERAND
         AIF   ('&$MNAME' EQ '').OR150 GO IF NO PNAM1 QUEUED
&$MNAME  EQU   &$MPNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC
.OR150   ANOP
&$MNAME  SETC  '&$MFNAM1(&$MRECUR)' QUEUE TAG FOR 'AND' FAILED
&$MFNAM1(&$MRECUR) SETC ''         NULLIFY TAG
         AGO   .LOOP010            AND CONTINUE
.AND160  AIF   ('&$MFNAM1(&$MRECUR)' NE '').AND170 SKIP IF NOT NEEDED
         $MGFNAME                  GET A NEW 'FNAM1'
.AND170  J&NC  &$MFNAM1(&$MRECUR)  B IF FALSE TO 'FAIL' TAG
&I       SETA  &I+2                BUMP TO NEXT
         AGO   .LOOP010            AND BACK
.FIN180  AIF   (&$MRECUR GT 1).MEND260 EARLY EXIT FOR RECURSIVE CALL
         AIF   ('&SYSLIST(&I+1)' EQ 'THENDO').FIN200 THIS IS EXPECTED
         AIF   ('&$MCVERB(&$MDGLVL+1)' EQ 'DO').FIN200 FOR 'DO' MACRO
         AIF   (&$MAXRC GT 4).FIN200 SKIP MESSAGE IF SERIOUS ERROR
         AIF   ('&SYSLIST(&I+1)' EQ '').FIN190 GO ISSUE INFO MNOTE
         MNOTE 4,'TERM ''&SYSLIST(&I+1)'' ACCEPTED AS END OF ''IF'' STAC
               TEMENT'
         AGO   .FIN200
.FIN190  MNOTE 0,'''IF'' MACRO NOT TERMINATED BY ''THENDO'' CLAUSE; PREC
               SENCE OF CLAUSE ASSUMED'
.FIN200  ANOP
&$MAXRC  SETA  0                   FOR FUTURE GENERATIONS
&$MDGLVL SETA  &$MDGLVL+1          UP IF-GROUP LEVEL
         $MLVLMSG &$MDGLVL,NESTING
&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET IF-GROUP SEQUENCE
&$MIFELS(&$MDGLVL) SETC 'F'        FOR 'IF-FAILED' BRANCH
&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET NAME FOR 'ENDO'
         AIF   ('&$MCVERB(&$MDGLVL)' NE '').SKIP210 ALREADY DEFINED?
&$MCVERB(&$MDGLVL) SETC 'IF'       SHOW VERB BEING EXECUTED
.SKIP210 ANOP
&NC      SETC  '&$MNC'             SET LOCAL VARIABLE
&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG
         AIF   ('&$MFNAM1(1)' NE '').FIN220 GO IF F-TAG NEEDED
         AIF   ('&$MNC' EQ '').FIN240 SKIP IF B&NC NOT REQ'D
         J&NC  &X                  B AROUND IF-GROUP IF FALSE
&$MNC    SETC  ''                  FOR FUTURES
         AGO   .FIN240             EXIT
.FIN220  AIF   ('&$MC' EQ '').FIN230 SKIP IF B&C NOT REQ'D
         J&NC  &X                  B AROUND IF-GROUP IF FALSE
&$MNC    SETC  ''                  FOR FUTURES
.FIN230  ANOP
&X       SETC  '&$MFNAM1(1)'       GET 'FNAM1' FROM LEVEL 1
&$MFNAM1(1) SETC ''                NOW NULLIFY IT
&Y       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG
&X       EQU   &Y                  EQUATE FOR NESTED LOGIC
.FIN240  AIF   ('&$MNAME' EQ '').FIN250 GO IF NO TAG QUEUED
&$MNAME  DC    0H'0'         *=*=* BEGINNING OF CONDITIONAL GROUP *=*=*
.FIN250  ANOP
&X       SETC  '&$MPNAM1(1)'       GET 'PNAM1' FROM LEVEL 1
         AIF   ('&X' EQ '').MEND260 GO IF NO 'PNAM1' FROM LEVEL 1
&$MPNAM1(1) SETC  ''               NULLIFY
&X       DC    0H'0'         *=*=* BEGINNING OF CONDITIONAL GROUP *=*=*
.MEND260 ANOP                      STANDARD EXIT
&$MRECUR SETA  &$MRECUR-1          REDUCE RECURSION COUNT
         $MLVLMSG &$MRECUR,RECURSION CONDITIONALLY ISSUE MESSAGE
         MEND
./ ADD NAME=OMGBLDEF 0100-02017-02017-1017-00004-00004-00000-GENTR02
         GBLA  &$MDGLVL,&$MDGERR,&$MRECUR,&$MBLATH
         GBLC  &$MFNBR(31),&$MDGNAM(255),&$MDGSEQ(255),&$MNAME,&$MNC
         GBLC  &$MIFELS(255),&$MLTAG(255),&$MPNAM1(31),&$MFNAM1(31)
         GBLC  &$MCVERB(255),&$MC
./ ADD NAME=THENDO   0112-01222-02067-1613-00020-00023-00000-GENTR02
         MACRO
&NAME    THENDO &COND '&COND' MUST BE CHAR(S) FOLLOWING 'B' OF EXTENDED
.*             MNEMONICS, EG 'E' OF 'BE' OR 'NO' OF 'BNO', ETC
         COPY  $MGBLDEF
         LCLC  &X,&Y
&Y       SETC  'N&COND'
         AIF   ('&COND'(1,1) NE 'N').SKIP05
&Y       SETC  '&COND'(2,1)
.SKIP05  ANOP
&$MDGLVL SETA  &$MDGLVL+1          UP DO-GROUP LEVEL
         $MLVLMSG
&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET DO-GROUP SEQUENCE
&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET DO-GROUP NAME
&$MIFELS(&$MDGLVL) SETC 'F'
         AIF   ('&NAME' NE '').SKIP07
&$MDGNAM(&$MDGLVL) SETC '$MDG&$MDGSEQ(&$MDGLVL)'
.SKIP07  J&Y   $MDF&$MDGSEQ(&$MDGLVL) SKIP DO-GROUP IF REL NOT TRUE
         AIF   ('&NAME' EQ '').SKIP10
&NAME    DC    0H'0'              NAME OF DO-GROUP
.SKIP10  MEND
