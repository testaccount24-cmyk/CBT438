THIS MEMBER IS AN INTRODUCTION TO THE MACRO DEFINITIONS WHICH COMPRISE
THE REMAINING MEMBERS OF THIS LIBRARY.  EACH OF THE MACROS HAS BEEN
TESTED, FOUND TO OPERATE CORRECTLY, AND TO PROVIDE AT LEAST SOME
MINIMUM AMOUNT OF DESIRABLE FUNCTIONALITY.  IF A PROBLEM CROPS UP,
EITHER IN YOUR UNDERSTANDING HOW TO USE A PARTICULAR MACRO OR GROUP OF
MACROS, OR WITH APPARENT PROGRAMMING PROBLEMS WITH THE PACKAGE, PLEASE
FEEL FREE TO CONTACT THE AUTHOR:

          DAN SNYDER                  614-847-8212
          COMPUWARE CORP
          1103 SCHROCK ROAD, STE 205
          COLUMBUS, OH 43229

THE FOLLOWING IS A DESCRIPTION OF THE CATEGORIES THAT THESE MACROS HAVE
BEEN CLASSIFIED INTO:

INTERNAL - THESE MACROS ARE TYPICALLY USED AS COMMON SERVICE ROUTINES
BY OTHER MACROS WITHIN THIS LIBRARY.  THEY PROVIDE SERVICES THAT WOULD
NOT NORMALLY BE CALLED FROM OPEN CODE.

STRUCTURED - MACROS THAT CONTROL THE CONDITIONAL OR REPETITIVE
EXECUTION OF A GROUP OF INSTRUCTIONS FOLLOWING THE GROUP-INITIATION
MACRO AND ENDING WITH A GROUP-TERMINATING MACRO.

DIAGNOSTIC - THE 'BEGTEST' AND 'ENDTEST' MACROS ALLOW YOU TO CONDITIONALLY
INCLUDE OR EXCLUDE SECTIONS OF CODE FROM A PARTICULAR ASSEMBLY.  THE CODE
CAN CONTINUE TO EXIST IN THE SOURCE MODULE.

GENERAL - THE 'EXECUTE' MACRO ALLOWS THE PROGRAMMER TO CREATE AN 'EX'
STATEMENT ON ONE LINE OF CODE.  IT GENERATES A 'LOCTR' STATEMEND NAMED
'DATA' TO ALLOW THE OUT-OF-LINE GENERATION OF THE 'EX'ECUTED INSTRUCTION.
THE NAME OF THE LOCTR AREA CAN BE CHANGED TO LOCAL REQUIREMENTS.

IN EACH OF THE EXAMPLES, IF '<NAME>' IS DISPLAYED IN THE NAME FIELD
OF A MACRO DEFINITION, THEN THE NAME FIELD IS A SUPPORTED OPTION FOR
THAT MACRO.

WHAT FOLLOWS IS A MOSTLY ALPHABETICAL LISTING OF ALL OF THE MACRO
DEFINITIONS INCLUDED IN THE PACKAGE, WITH ITS IDENTIFYING MACRO TYPE:

$MENDDO1  INTERNAL
$MENDDO2  INTERNAL
$MGBLDEF  INTERNAL
$MGFNAME  INTERNAL
$MGFNBR   INTERNAL
$MGPNAME  INTERNAL
AFTER     STRUCTURED
BEGTEST   DIAGNOSTIC
DO        STRUCTURED
DOEXIT    STRUCTURED
ELSE      STRUCTURED
ELSEDO    STRUCTURED
ELSEIF    STRUCTURED
ENDAFTER  STRUCTURED
ENDELSE   STRUCTURED
ENDEVERY  STRUCTURED
ENDFIRST  STRUCTURED
ENDIF     STRUCTURED
ENDO      STRUCTURED
ENDTEST   DIAGNOSTIC
EVERY     STRUCTURED
EXECUTE   GENERAL
FIRST     STRUCTURED
IF        STRUCTURED
THENDO    STRUCTURED

                            DIAGNOSTIC

THE MACROS IN THIS GROUP FURNISH VARIOUS AIDS THAT CAN BE USED IN
DIAGNOSING THE EXECUTION OF A PROGRAM.  THE 'BEGTEST' AND 'ENDTEST'
MACROS ALLOW MULTIPLE LINES OF CODE TO BE INCLUDED OR EXCLUDED FROM
AN ASSEMBLY, BASED ON THE VALUE OF A GLOBAL SET SYMBOL.

BEGTEST
THIS MACRO HEADS A GROUP OF INSTRUCTIONS THAT ARE CONDITIONALLY
INCLUDED OR EXCLUDED FROM A PARTICULAR ASSEMBLY. THE GROUP MUST BE
TERMINATED WITH AN 'ENDTEST' MACRO.  THE 'BEGTEST' REQUIRES ONE
POSITIONAL OPERAND.  IF THE OPERAND IS NUMERIC, THEN THAT VALUE IS
COMPARED WITH THE GLOBAL TYPE 'A' SET SYMBOL &TESTLVL.  IF THE OPERAND
IS GREATER THAN &TESTLVL, THEN THE INSTRUCTIONS BETWEEN THE 'BEGTEST'
AND 'ENDTEST' ARE EXCLUDED FROM THIS ASSEMBLY, OTHERWISE THEY ARE
INCLUDED:

          GBLA  &TESTLVL
 &TESTLVL SETA  10
 ...
<NAME>    BEGTEST 5
          WTO   'HELP'
<NAME>    ENDTEST ,

IN THIS CASE, THE 'WTO' STATEMENT WILL BE ASSEMBLED.  IF &TESTLVL HAD
BEEN SET TO 0 (ZERO), THEN THE 'WTO' WOULD HAVE BEEN EXCLUDED FROM
THIS ASSEMBLY.

BE VERY CAREFUL ABOUT GIVING A NAME TO THE 'ENDTEST' MACRO.  IF YOU
CODE A BRANCH INSTRUCTION WITH THAT NAME AS THE OPERAND, AND THAT
'ENDTEST' INSTRUCTION IS OMITTED FROM THE PROGRAM BECAUSE OF THE VALUE
OF &TESTLVL, THEN YOU WILL GET AN ASSEMBLY ERROR.  IT WOULD BE SAFE TO
HAVE A BRANCH TO THAT TAG ONLY WITHIN THE GROUP OF INSTRUCTIONS HEADED
BY THE 'BEGTEST' MACRO.

IF THE VALUE OF THE POSITIONAL OPERAND OF THE 'BEGTEST' IS 'A', 'B',
'C', OR 'D', THEN THE LOGIC IS BASED ON THE SETTING OF THE GLOBAL TYPE
'C' SET SYMBOL &$A, &$B, &$C OR &$D RESPECTIVELY:

          GBLC  &$A
&$A       SETC  'Y'     ANY OTHER VALUE CAUSES EXCLUSION
...
<NAME>    BEGTEST A
          WTO   'OPT CODE INCLUDED'
<NAME>    ENDTEST ,

SINCE THE SET SYMBOL &$A WAS SET TO 'Y', THE 'WTO' WILL BE INCLUDED IN
THIS ASSEMBLY.  IF &$A HAD BEEN SET TO ANY OTHER VALUE THEN THE CODE
WOULD NOT BE INCLUDED IN THIS ASSEMBLY.

ENDTEST
THIS ONE NEEDS TO BE USED ONLY IN CONJUNCTION WITH THE 'BEGTEST'
MACRO. IT IS USED TO END A GROUP OF CONDITIONALLY INCLUDED LINES OF
CODE. PLEASE SEE THE DOCUMENTATION FOR 'BEGTEST'.

EXECUTE
THIS ONE MAKES IT POSSIBLE TO CONSTRUCT AN 'EX' INSTRUCTION WITH ONE
LINE OF CODE.  IF YOU'VE NEVER USED THE 'EX' INSTRUCTION, YOU'RE
PROBABLY BETTER OFF SKIPPING THE REST OF THIS 'EXECUTE' DOCUMENTATION.
IF YOU HAVE ALREADY USED IT, OR IF YOU'RE VERY BRAVE, THEN HERE GOES.
IT REQUIRES THREE POSITIONAL OPERANDS. THE FIRST IS A GPR (IT DOESN'T
HAVE TO BE WITHIN PARENTHESES, SINCE IT HAS TO BE A GPR), THE SECOND
IS THE OP CODE FOR THE INSTRUCTION BEING 'EX'ECUTED, AND THE THIRD
CONSISTS OF ALL OF THE OPERANDS OF THE INSTRUCTION BEING 'EX'ECUTED,
AND THEY MUST BE ENCLOSED WITHIN PARENTHESES.

 <NAME>   EXECUTE R15,MVC,(FIELDA(0),FIELDB)
+<NAME>   EX     R15,$EX1234         GENERATED
+...
+$EX1234  MVC   FIELDA(0),FIELDB     GENERATED

NOTE THAT THE THIRD OPERAND IS GENERATED OUT-OF-LINE.
                            INTERNAL

SINCE MOST OF THESE MACRO DEFINITIONS PROVIDE SERVICES FOR THE OTHER
MACROS IN THIS PACKAGE, THEY ARE NOT INDIVIDUALLY DOCUMENTED HERE.

                            STRUCTURED

THIS SET OF MACROS CAUSES A CONDITIONAL AND/OR REPETITIVE EXECUTION OF
A GROUP OF ONE OR MORE INSTRUCTIONS.  FOR CONVENIENCE, LET'S CALL A
GROUP OF INSTRUCTIONS THAT MIGHT OR MIGHT NOT BE EXECUTED ONE TIME, OR
MULTIPLE TIMES, A 'CR-GROUP', FOR 'C'ONDITIONAL/'R'EPETITIVE.

IF
THIS IS THE HEART OF THE STRUCTURED MACROS. IT SUPPORTS THE
CONDITIONAL EXECUTION OF A CR-GROUP BASED ON ONE OR MORE TESTS. EACH
TEST PHRASE, CONTAINED WITHIN PARENTHESES, MUST CONSIST OF AN OP-CODE,
A FIRST OPERAND, A SECOND OPERAND, AND A CONDITION. (NOTE OP-CODES
WITH OTHER THAN TWO OPERANDS ARE SUPPORTED, BUT THE OP-CODE MUST
ALWAYS BE FIRST AND THE CONDITION MUST ALWAYS BE LAST WITHIN THE
PHRASE.)  FOLLOWING THE LAST PHRASE, THE FINAL POSITIONAL PARAMETER
MUST BE 'THENDO':

 <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO
            ...
          ENDIF ,

NOTE THAT THE FORMAT OF THE CONDITIONAL PHRASE IS FIXED IN THAT:
1. THE OP-CODE IS ALWAYS THE FIRST OPERAND
2. THE CONDITION IS ALWAYS LAST
3. THE OPERANDS ARE ALWAYS IN THEIR ORDINAL POSITIONS IN BETWEEN

EXAMPLES:

         IF   (UPT,Z),THENDO          INST WITH ZERO OPERANDS

         IF   (SSCH,12,Z),THENDO                ONE OPERAND

         IF   (CLI,LCLSW,C'0',E),THENDO         TWO OPERANDS

         IF   (SRP,PFIELD1,PFIELD2,5,Z),THENDO  THREE OPERANDS

NOTE THAT THE OP-CODE 'CLC' WILL BE USED THROUGHOUT THESE EXAMPLES.
WHEN YOU CODE YOUR PROGRAM, USE WHATEVER INSTRUCTION IS APPORPRIATE,
SO LONG AS IT IS ONE THAT SETS THE PROCESSOR'S CONDITION CODE FIELD.
IT COULD EVEN BE A MACRO STATEMENT, SO LONG AS THE CONDITION CODE
IS SET BY ONE OF THE INSTRUCTIONS GENERATED BY THE MACRO EXPANSION SO
THAT IT CAN BE TESTED BY THE BRANCH-ON-CONDITION THAT FOLLOWS.

IN THIS EXAMPLE, IF FIELDA IS EQUAL TO FIELDB, THEN THE CR-GROUP
WILL BE EXECUTED.  THE CONDITION, CODED AS THE LAST POSITIONAL
SUB-PARAMETER, CAN BE ANY OF THE EXTENDED BRANCH NMEMONICS:

  E NE H NH L NL M NM O NO P NP Z NZ

IN THE ABOVE EXAMPLE, THE MACRO EXPANDS INTO:

 <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO
+<NAME>   CLC   FIELDA,FIELDB    GENERATED
+         BNE   $TAG             BRANCH AROUND 'IF' GROUP
          ...                    YOUR INSTRUCTIONS
          ENDIF ,
+$TAG     DS    0H

NOTE: IN THIS SIMPLE EXAMPLE, THE CONDITION 'E' STATES THAT THE IF-GROUP
IS TO BE EXECUTED IF THE 'CLC' RESULTS IN AN 'EQUAL'.  TO CAUSE THIS
LOGIC TO OCCUR, A BRANCH ON THE OPPOSITE CONDITION IS CREATED TO BYPASS
THE IF-GROUP, MEANING THAT PROGRAM EXECUTION 'FALLS THROUGH' INTO THE
IF-GROUP WHEN THE SPECIFIED CONDITION IS MET.

LIKEWISE, FOR THE PHRASE '(CLC,FIELDA,FIELDB,NE)', THE BYPASSING BRANCH
INSTRUCTION GENERATED WOULD BE A 'BE    $TAG'.

NOTE: '$TAG' INDICATES THAT THE MACRO GENERATION PROCESS WILL GENERATE
AN UNIQUE TAG, WHOSE NAME BEGINS WITH '$', AND ENDS WITH A UNIQUE NUMBER
OBTAINED FROM A SYSTEM COUNTER.

IF YOU HAD CODED 'NE' AS THE CONDITION, THEN IT WOULD EXPAND TO:

 <NAME>   IF    (CLC,FIELDA,FIELDB,NE),THENDO
+<NAME>   CLC   FIELDA,FIELDB    GENERATED
+         BE    $TAG             BRANCH AROUND 'IF' GROUP
          ...                    YOUR INSTRUCTIONS
          ENDIF ,
+$TAG     DS    0H

     TO EXECUTE THE CR-GROUP IF EITHER ONE OF TWO CONDITIONS IS
TRUE, THE FORMAT IS:

 <NAME>   IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO

     ALTERNATE FORMAT:
                                                               72
 <NAME>   IF    (CLC,A,B,NE),OR,                                C
           (CLC,C,D,NE),THENDO

     NOTE THAT, AS SHOWN IN THE EXAMPLES, YOU NEED TO ENCLOSE THE
CONDITIONAL PHRASES WITHIN PARENTHESES, AND THAT YOU DO NOT
ENCLOSE THE CONNECTING PHRASES ('OR' OR 'AND') OR THE FINAL
'THENDO' WITHIN PARENTHESES.

     SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING
EXAMPLE, THE CR-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR
IF BOTH THE SECOND AND THIRD ARE TRUE:

 <NAME>   IF    (CLC,A,B,E),OR,                                 C
                (CLC,C,D,E),AND,                                C
                (CLC,E,F,E),THENDO

     IF YOU NEED TO CREATE A SUB-GROUP OF PHRASES CONNECTED BY
'OR' CONNECTORS, AND THEN CONNECT THIS SUB-GROUP VIA AN 'AND'
WITH ANOTHER CONDITION (WHICH MAY ITSELF CONSIST OF ANOTHER
SUB-GROUP OF CONDITIONS), THEN YOU NEED TO ENCLOSE THE ENTIRE
SUB-GROUP WITHIN AN ADDITIONAL PAIR OF PARENTHESES:

                * <-NESTING PARENTHESES -> *
 <NAME>   IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C
                (CLC,E,F,E),THENDO

     THE AUTHOR OF THESE MACROS PREFERS THE FORMAT:

 <NAME>   IF    ((CLC,A,B,E),OR,                                C
                (CLC,C,D,E)),AND,                               C
                (CLC,E,F,E),THENDO

     I GUESS THE BOTTOM LINE IS THAT S/390 ASSEMBLER IS SOMEWHAT OF A
PAIN, NO MATTER HOW YOU FORMAT THE STATEMENTS!

     GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED
TO DEFINE THE LOGIC DESIRED. THE LIMIT IS THAT ANY SINGLE
PARAMETER IS LIMITED BY THE ASSEMBLER TO 255 CHARACTERS IN LENGTH.

     NOTE THAT THE CONDITIONAL PHRASES ARE EXECUTED IN THE ORDER
THAT THEY ARE WRITTEN.  THEREFORE, IF THERE ARE ONE OR MORE PHRASES
THAT MORE OFTEN THAN NOT WOULD RESULT IN AN ABBREVIATED PASS THRU THE
CONSTRUCT, THEN YOU SHOULD CODE THOSE PHRASES FIRST (MAINTAINING THE
LOGIC REQUIRED FOR THE DESIRED RESULT, OF COURSE!).

     EACH CR-GROUP MUST BE TERMINATED WITH AN 'ENDO' STATEMENT
OR AN 'ELSE' - 'ENDELSE' COMBINATION:

          ENDIF ,
                 - OR -
          ELSE  ,
     ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS
          ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')

     ALTERNATIVELY, A CR-GROUP CAN BE TERMINATED AS FOLLOWS:

          ELSEIF  (CLC,G,H,E),THENDO ...
            ...
          ELSEIF  (CLC,I,J,E),THENDO ...
            ...
          ELSE  ,
            ...
          ENDELSE ,

     ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL
     'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY
     ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE
     GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.

THENDO
THE SIMPLIST OF THESE IS THE 'THENDO' MACRO THAT MUST BE TERMINATED BY
AN 'ENDO':
         CLC   FIELDA,FIELDB
         THENDO E
         ...
         ENDO

THE STATEMENTS REPRESENTED BY THE '...' WILL BE EXECUTED ONLY IF THE
'CLC' RESULTED IN AN 'E'. OPTIONALLY YOU MAY CODE AN 'ELSE' STATEMENT,
AND/OR ONE OR MORE 'ELSEDO' STATEMENTS:

         TRT   FIELDA,TABLE1
         THENDO L       DO IF NON-ZERO FUNCTION AND NOT LAST ARG
         ...
         ELSEDO H       DO IF NON-ZERO FUNCTION AND LAST ARG
         ...
         ELSEDO E       DO IF ALL FUNCTION BYTES ZERO
         ...
         ENDO

SINCE THE 'TRT' CAN ONLY GENERATE CC'S OF 0, 1, OR 2, THAT LAST
'ELSEDO E' COULD HAVE BEEN REPLACED BY 'ELSE'.  AT ANY RATE, THIS IS
A VIABLE WAY TO TEST VALUES OF THE CONDITION CODE THAT ARE SET BY ONE
INSTRUCTION.  AS YOU WILL SEE WITH THE 'IF' STATEMENT, THE
INSTRUCTION(S) THAT SET THE CC AND THE TEST FOR THE VALUE OF THE CC
ALL FORM PART OF THE SAME STATEMENT, SO THAT IT IS PROBABLY BETTER
TO USE THE 'IF' AND 'ELSEIF' WITH INSTRUCTIONS THAT DO NOT MODIFY THEIR
OPERANDS (SUCH AS 'CLC' OR 'TM' ETC.).

EACH CR-GROUP MUST BE HEADED BY ONE OF THE FOLLOWING MACRO STATEMENTS:

  AFTER      DO     EVERY      FIRST      IF        THENDO

AND MUST BE TERMINATED BY ONE OF THE FOLLOWING:

  ENDAFTER   ENDO   ENDEVERY   ENDFIRST   ENDIF

IT IS SOMEWHAT OVERSIMPLIFYING TO SAY THAT ALL OF THE ENDXXXXX MACROS
SIMPLY INVOKE 'ENDO', BUT THE TRUTH IS THAT THE INDIVIDUAL ENDXXXXX
MACROS ARE MORE FOR PROGRAM DOCUMENTATION THAN THEY ARE FOR INTERNAL
LOGIC DIFFERENCES. SO, IF YOU END AN CR-GROUP WITH AN 'ENDAFTER'
MACRO, NO DIAGNOSTICS WILL BE ISSUED AND YOUR PROGRAM WILL WORK THE
SAME AS IF YOU HAD CODED AN 'ENDIF'.

CR-GROUPS MAY BE NESTED TO ANY DESIRED LEVEL:

          IF    ...
          ...
            DO    ...
            ...
            ENDO  ,
          ...
          ENDIF ,

YOU MAY FIND IT EFFECTIVE TO INDENT AT EACH LEVEL OF NESTING, BUT
BEWARE - THE CONTINUATION COLUMN IS ALWAYS THE SAME (16 IS THE
DEFAULT).

THERE ARE TWO ADDITIONAL SIGNIFICANT MACROS THAT CAN BE USED WITHIN
THIS PACKAGE OF STRUCTURED PROGRAMMING MACROS.  THE 'ELSEIF' MACRO CAN
BE USED FOLLOWING AN 'IF' OR ANOTHER 'ELSEIF' MACRO, AND SUPPORTS THE
SAME TYPES OF LOGIC THAT THE 'IF' MACRO SUPPORTS.  THE 'ELSE' MACRO
CAN FOLLOW AN 'IF', 'ELSEIF', 'AFTER', 'EVERY' OR 'FIRST' MACRO, AND
ALLOWS ITS CR-GROUP TO BE EXECUTED IF ALL OF THE PRECEDING CR-GROUPS
WERE NOT EXECUTED.

IN GENERAL, I WOULD SUGGEST THAT YOU NOT CREATE A NAME FIELD FOR A MACRO
THAT ENDS A CR-GROUP. IT MIGHT BE PERMISSIBLE IF YOU NEED TO EXIT THE
CR-GROUP FROM SOMEWHERE DEEP INSIDE IT, BUT AS SOON AS YOU START NAMING
STATEMENTS, IT SIGNALS EVEN MORE BAD HABITS TO COME.

AFTER
THIS MACRO HEADS A CR-GROUP THAT WILL BE SKIPPED FOR THE FIRST 'N'
PASSES THROUGH THIS SECTION OF CODE, AND THEN EXECUTED EVERY PASS
THROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING
TERM.

 <NAME>  AFTER 1000000
            ...
         ENDAFTER ,

DO
THIS ONE PROVIDES REPETITIVE EXECUTION OF A CR-GROUP. THERE ARE
SEVERAL OPTIONS: THE FIRST IS TO CODE A NUMERIC SELF-DEFINING TERM,
WHICH CAUSES THE CR-GROUP TO BE EXECUTED THAT NUMBER OF TIMES:

 <NAME>   DO    5
            ...
          ENDO  ,

A SLIGHT VARIATION IS TO CODE:

 <NAME>  DO    FOREVER
           ...
         ENDO  ,

THIS CAUSES THE CR-GROUP TO BE CONTINUOUSLY EXECUTED UNTIL SOMETHING
EITHER WITHIN THE LOOP OR SOMETHING OUTSIDE THE PROGRAM (TIME
EXCEEDED, ETC) CAUSES THE LOOP TO BE BROKEN.

IF YOU CODE:

 <NAME>  DO    MYVARBL
           ...
         ENDO  ,

THEN 'MYVARBL' MUST BE A PACKED DECIMAL VARIABLE WHICH YOU HAVE
ALREADY INITIALIZED TO THE VALUE FOR THE NUMBER OF TIMES THAT YOU
WANT THIS CR-GROUP REPEATED. BE VERY CAREFUL ABOUT MODIFYING THIS
VARIABLE FROM WITHIN THE LOOP. ITS VALUE IS CAPTURED ONLY AT THE
BEGINNING OF THE EXECUTION OF THE CR-GROUP, AND ANY CHANGE TO THE
VALUE OF THE VARIABLE WILL TAKE EFFECT THE NEXT TIME THE 'DO'
STATEMENT IS ENCOUNTERED.

IF YOU WANT TO REPEAT A CR-GROUP BASED ON ONE OR MORE CONDITIONS,
THEN YOU CAN USE EITHER ONE OF THE FOLLOWING:

 <NAME>  DO    UNTIL=(...)
           ...
         ENDO  ,

         .. OR ..

 <NAME>  DO    WHILE=(...)
           ...
         ENDO  ,

IN THE FIRST OF THESE TWO EXAMPLES, THE CR-GROUP WILL BE EXECUTED
REPETITIVELY UNTIL ONE OR MORE OF THE CONDITIONS IS MET. IN THE
SECOND, IT WILL BE EXECUTED SO LONG AS ONE OR MORE OF THE CONDITIONS
IS MET.  IN BOTH OF THESE EXAMPLES, THE VALUES WITHIN THE PARENTHESES
ARE THE SAME AS FOR THE 'IF' MACRO. PLEASE SEE ITS DOCUMENTATION FOR
THE DETAILS.  THE ONLY DIFFERENCE BETWEEN THE OPERANDS HERE AND FOR
THE 'IF' MACRO IS THAT, IF THE CONDITION IS COMPLEX, THAT IS, IF IT
CONSISTS OF MULTIPLE CONDITIONS CONNECTED WITH 'AND' AND/OR 'OR'
CLAUSES, THEN THE ENTIRE OPERAND MUST BE ENCLOSED WITHIN ONE
ADDITIONAL LEVEL OF PARENTHESES:

 <NAME>   DO    UNTIL=((...),OR,(...))
                      *              *  <== REQUIRED IF COMPLEX
            ...
          ENDO  ,

ONE ADDITIONAL KEYWORD OPERAND IS AVAILABLE:

 <NAME>   DO    UNTIL=(...),TEST=AFTER
            ...
          ENDO  ,

          .. OR ..

 <NAME>   DO    WHILE=(...),TEST=AFTER
            ...
          ENDO  ,

THE 'TEST=AFTER' CAUSES THE CR-GROUP TO BE EXECUTED ONE TIME BEFORE
THE CONDITIONAL TESTS ARE MADE. DEFAULT IS 'TEST=BEFORE', WHERE THE
CR-GROUP MIGHT NOT BE EXECUTED EVEN ONCE, DEPENDING ON THE INITIAL
CONDITIONS.

DOEXIT
THE 'DOEXIT' MACRO CAUSES EXECUTION TO TRANSFER TO THE FIRST INSTRUCTION
FOLLOWING THE 'ENDO' STATEMEMT:

 <NAME>   DO    UNTIL=(...)
            ...
            DOEXIT ,
            ...
          ENDO  ,

IF THERE IS NESTED LOGIC CONSISTING OF 'IF' STATEMENTS AND 'DO'
STATEMENTS, A 'DOEXIT' STATEMENT ALWAYS TRANSFERS CONTROL TO THE
STATEMENT FOLLOWING THE INNERMOST 'DO' STATEMENT:

<NAME>    DO    UNTIL=(...)
            ...
            IF    (...),THENDO
              ...
              DOEXIT , TRANSFERS TO STATEMENT FOLLOWING .. |
              ...                                          |
              DO    WHILE=(...)                            |
                ...                                        |
                DOEXIT , TRANSFERS TO STMT FOLLOWING |     |
                ...                                  |     |
              ENDO  ,                 <---------------     |
              ...                                          |
            ENDIF ,                                        |
            ...                                            |
          ENDO  ,                     <---------------------
ELSE
THIS MACRO MAY BE CODED ONLY WITHIN A CR-GROUP HEADED BY AN 'AFTER',
'ELSEIF', 'EVERY' OR 'FIRST' CR-GROUP HEADER.  IT CAUSES EXECUTION OF
ITS CR-GROUP IF ALL OF THE PREVIOUS CR-GROUPS HAVE BEEN BYPASSED:

 <NAME>   AFTER 1000000
            ...             EXECUTED AFTER 1,000,000 PASSES
          ELSE  ,
            ...             EXECUTED FIRST 1,000,000 PASSES
          ENDELSE ,

ELSEIF
THIS MACRO MAY FOLLOW ONLY ANOTHER 'ELSEIF' STATEMENT, OR AN 'IF'
STATEMENT. IT SUPPORTS ALL THE OPTIONS OF THE 'IF' STATEMENT. PLEASE
SEE THE 'IF' STATEMENT FOR THE DETAILS.

 <NAME>   IF    (...),THENDO
            ...
          ELSEIF (...),THENDO
            ...
          ENDELSE ,

ENDAFTER
ENDELSE
ENDEVERY
ENDFIRST
ENDIF
ENDO
THESE MACROS ARE EQUIVALENT, AND SHOULD BE USED TO END THEIR
RESPECTIVE TYPES OF CR-GROUPS. THE ONE 'INTERESTING' PARAMETER IS THE
'DOGROUP=' KEYWORD.  IF YOU NAMED A PREVIOUS CR-GROUP HEADER MACRO (SUCH
AS 'IF' OR 'DO'), AND YOU HAVE NESTED CR-GROUPS, THEN YOU MAY TERMINATE
MULTIPLE CR-GROUPS WITH ONE 'ENDO' MACRO BY NAMING THE OUTERMOST GROUP
THAT YOU WANT TO TERMINATE, AND THEN NAMING THAT GROUP ON THE 'ENDO'
MACRO:

 MAINGRP IF    (...),THENDO
           ...
           IF    (...),THENDO
             ...
         ENDIF DOGROUP=MAINGRP

IF YOU WANT TO TERMINATE ALL CR-GROUPS, THEN CODE THE 'MAGIC' KEYWORD:

 MAINGRP IF    (...),THENDO
           ...
           IF    (...),THENDO
             ...
         ENDO  DOGROUP=*ALL*

SINCE '*ALL*' IS NOT A VALID ASSEMBLER TAG, IT CAN BE SAFELY USED AS
THE FLAG TO INDICATE THAT ALL CURRENT CR-GROUPS ARE TO BE TERMINATED.

EVERY
THIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED EVERY 'N'TH PASS
THROUGH THIS SECTION OF CODE. 'N' MUST BE A NUMERIC SELF-DEFINING TERM.

 <NAME>  EVERY 1000000
            WTO   'ANOTHER 1,000,000 PASSES'
         ENDEVERY ,

FIRST
THIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED FOR THE FIRST 'N'
PASSES THROUGH THIS SECTION OF CODE, AND THEN SKIPPED EVERY PASS
THROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING
TERM.

 <NAME>  FIRST 1000000
            ...
         ENDAFTER ,

ITS DESIGNED USE IS TO DO STUFF ONLY ON THE FIRST PASS THROUGH A
SECTION OF CODE

 <NAME>  FIRST 1
           OPEN  (...)
         ENDFIRST ,

THENDO
THIS WAS THE ORIGINAL STRUCTURED MACRO OF THIS PACKAGE.  IT IS NOT SO
POWERFUL AS THE NEWER ONES, BUT YOU MIGHT FIND SOME USE FOR IT. ITS ONLY
POSITIONAL PARAMETER MUST BE ONE OF THE CONDITIONS THAT YOU CAN APPEND
TO THE 'B' TO CREATE ONE OF THE EXTENDED BRANCH INSTRUCTIONS, SUCH AS
'E'.  PLEASE REFER TO THE DOCUMENTATION FOR THE 'IF' MACRO FOR A
COMPLETE LIST.

THIS MACRO DEPENDS ON A PREVIOUS INSTRUCTION IN THE PROGRAM, SUCH AS A
'CLR', TO SET THE CONDITION CODE. ITS CR-GROUP WILL THEN BE EXECUTED IF
THE OPERAND SATISFIES THE SETTING OF THE CONDITION CODE:

          CLR   R5,R6
 <NAME>   THENDO E
            ...
          ENDO  ,

          -- OR --

          CLC   R5,R6
 <NAME>   THENDO E
            ...
          ELSE  ,
            ...
          ENDO  ,

IN THIS EXAMPLE, THE FIRST CR-GROUP WILL BE EXECUTED IF R5 = R6, AND
THE SECOND WILL BE EXECUTED IF THEY ARE UNEQUAL.

THAT'S IT, FOLKS. NO OTHER OPTIONS FOR 'THENDO' (OTHER THAN NESTING).

