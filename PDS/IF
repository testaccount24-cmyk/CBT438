         MACRO
&NAME    IF    &EXP                MULTIPLE OPERANDS VIA &SYSLIST
         COPY  $MGBLDEF            BRING IN GLOBAL SYMBOLS
         LCLA  &I,&J,&K            USED TO SCAN &SYSLIST OPERANDS
         LCLC  &X,&Y,&OP,&OPND1,&OPND2,&OPND3,&C,&NC
&$MRECUR SETA  &$MRECUR+1          INCREASE RECURSION COUNT
&I       SETA  1                   SET TO FIRST POSITIONAL
&$MNAME  SETC  '&NAME'             TAG FOR FIRST TEST
.LOOP10  AIF   (N'&SYSLIST LT &I).FINISH GO TO FINISH IF DONE
         AIF   ('&SYSLIST(&I)'(1,1) NE '(').FATAL   MUST BE '('
         AIF   ('&SYSLIST(&I)'(2,1) EQ '(').RECURS GO IF NESTED
&OP      SETC  '&SYSLIST(&I,1)'    OP-CODE IS ALWAYS 1ST SUB-OPERAND
&J       SETA  (N'&SYSLIST(&I))    NUMBER OF SUBPARAMETERS FOR THIS ONE
         AIF   (&J NE 2).TEST1     GO TEST FOR 1-OPERAND INST
&$MNAME  &OP   ,                   ZERO OPERANDS - SET CONDITION CODE
&$MC     SETC  '&SYSLIST(&I,2)'    CONDITION IS ALWAYS LAST SUB-OPERAND
         AGO   .FINGEN             GO SET UP BRANCH INST
.TEST1   ANOP  ,
&OPND1   SETC  '&SYSLIST(&I,2)'    FIRST (ONLY?) OPERAND
         AIF   (&J NE 3).TEST2     GO TEST FOR 2-OPERAND INST
&$MNAME  &OP   &OPND1              ONE OPERAND - SET CONDITION CODE
&$MC     SETC  '&SYSLIST(&I,3)'    CONDITION IS ALWAYS LAST SUB-OPERAND
         AGO   .FINGEN             GO SET UP BRANCH INST
.TEST2   ANOP  ,
&OPND2   SETC  '&SYSLIST(&I,3)'    SECOND OPERAND
         AIF   (&J NE 4).TEST3     GO TEST FOR 3-OPERAND INST
&$MNAME  &OP   &OPND1,&OPND2       TWO OPERANDS - SET CONDITION CODE
&$MC     SETC  '&SYSLIST(&I,4)'    CONDITION IS ALWAYS LAST SUB-OPERAND
         AGO   .FINGEN             GO SET UP BRANCH INST
.TEST3   ANOP  ,
&OPND3   SETC  '&SYSLIST(&I,4)'    THIRD OPERAND
         AIF   (&J NE 5).ERROR1    GO ISSUE ERROR MESSAGE
&$MNAME  &OP   &OPND1,&OPND2,&OPND3 THREE OPERANDS - SET CONDITION CODE
&$MC     SETC  '&SYSLIST(&I,5)'    CONDITION IS ALWAYS LAST SUB-OPERAND
         AGO   .FINGEN             GO SET UP BRANCH INST
.ERROR1  ANOP  ,
&K       SETA  ((&I+1)/2)          GET SEQUENCE # OF PHRASE IN ERROR
         MNOTE 12,'INVALID NUMBER OF PARMS (&J) IN CONDITIONAL PHRASE #*
               &K &SYSLIST(&I); IT WILL BE DELETED FROM THE MACRO EXPAN*
               SION'
&I       SETA  &I+2                INCREMENT
         AGO   .LOOP10             BACK FOR MORE
.FINGEN  ANOP                      COND CODE NOW SET - TEST IT
&$MNC    SETC  'N&$MC'             SET TO 'NOT'-CONDITION CODE
         AIF   ('&$MC'(1,1) NE 'N').SKIP12 FALL THROUGH IF 'NE' ETC
&$MNC    SETC  '&$MC'(2,1)         ORIG WAS 'NX' - SET TO 'X'
.SKIP12  ANOP
&$MNAME  SETC  ''                  C'MON - NO DUPLICATE TAGS, PLEASE
         AIF   ('&SYSLIST(&I+1)' EQ 'OR').OR10 GO IF 'OR'
         AIF   ('&SYSLIST(&I+1)' EQ   'AND').OR10 GO IF 'AND'
         AGO   .FINISH             NOT 'OR' OR 'AND' - ASSUME END
.RECURS  ANOP                      HERE FOR RECURSIVE CALL
&$MNAME  IF    &SYSLIST(&I,1),&SYSLIST(&I,2),&SYSLIST(&I,3),           C
               &SYSLIST(&I,4),&SYSLIST(&I,5),&SYSLIST(&I,6),           C
               &SYSLIST(&I,7),&SYSLIST(&I,8),&SYSLIST(&I,9),           C
               &SYSLIST(&I,10),&SYSLIST(&I,11),&SYSLIST(&I,12),        C
               &SYSLIST(&I,13),&SYSLIST(&I,14),&SYSLIST(&I,15),        C
               &SYSLIST(&I,16),&SYSLIST(&I,17),&SYSLIST(&I,18),        C
               &SYSLIST(&I,19),&SYSLIST(&I,20),&SYSLIST(&I,21)
.REC10   AIF   ('&$MFNAM1(&$MRECUR+1)' EQ '').REC12 GO IF NO FNAM1(+1)
         AIF   ('&$MFNAM1(&$MRECUR)' EQ '').REC11 GO IF NO FNAM1
&X       SETC  '&$MFNAM1(&$MRECUR+1)' TEMP FOR FNAM1(+1)
&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY
&X       EQU   &$MFNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC
         AGO   .REC12              TEST PNAM1
.REC11   ANOP
&$MFNAM1(&$MRECUR) SETC '&$MFNAM1(&$MRECUR+1)' PROMOTE
&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY
.REC12   AIF   ('&$MPNAM1(&$MRECUR+1)' EQ '').REC19 GO IF NO PNAM1(+1)
&$MNAME  SETC  '&$MPNAM1(&$MRECUR+1)' QUEUE FOR TEST INSTRUCTION
&$MPNAM1(&$MRECUR+1) SETC ''       NULLIFY
.REC19   AIF   ('&SYSLIST(&I+1)' EQ  'OR').OR10 GO IF 'OR'
         AIF   ('&SYSLIST(&I+1)' EQ 'AND').OR10 GO IF 'AND'
         AGO   .FINISH             NOT 'OR' OR 'AND' - ASSUME END
.FATAL   MNOTE 8,'MISSING PARENS AT &SYSLIST(&I) - TERMINATED'
         AGO   .MEND
.OR10    ANOP                      COMMON FOR 'OR' AND 'AND'
&NC      SETC  '&$MNC'             GEN LOCAL VARIABLES FOR
&C       SETC  '&$MC'              . CONDITION CODE TESTS
&$MNC    SETC  ''                  NULLIFY THE GLOBAL VARIABLES
&$MC     SETC  ''                  . SINCE LOCALS WILL BE USED
         AIF   ('&SYSLIST(&I+1)' EQ 'AND').AND10    GO IF 'AND'
         AIF   ('&$MPNAM1(&$MRECUR)' NE '').OR12 SKIP IF NOT NEEDED
         $MGPNAME                  GET A NEW 'PNAM1'
.OR12    J&C   &$MPNAM1(&$MRECUR)  B IF TRUE TO 'PASS' TAG
&I       SETA  &I+2                BUMP TO NEXT OPERAND
         AIF   ('&$MNAME' EQ '').OR20 GO IF NO PNAM1 QUEUED
&$MNAME  EQU   &$MPNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC
.OR20    ANOP
&$MNAME  SETC  '&$MFNAM1(&$MRECUR)' QUEUE TAG FOR 'AND' FAILED
&$MFNAM1(&$MRECUR) SETC ''         NULLIFY TAG
         AGO   .LOOP10             AND CONTINUE
.AND10   AIF   ('&$MFNAM1(&$MRECUR)' NE '').AND12 SKIP IF NOT NEEDED
         $MGFNAME                  GET A NEW 'FNAM1'
.AND12   J&NC  &$MFNAM1(&$MRECUR)  B IF FALSE TO 'FAIL' TAG
&I       SETA  &I+2                BUMP TO NEXT
         AGO   .LOOP10             AND BACK
.FINISH  AIF   (&$MRECUR GT 1).MEND NO PROCESSING FOR NESTED
&$MDGLVL SETA  &$MDGLVL+1          UP DO-GROUP LEVEL
&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET DO-GROUP SEQUENCE
&$MIFELS(&$MDGLVL) SETC 'F'        FOR 'IF-FAILED' BRANCH
&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET NAME FOR 'ENDO'
         AIF   ('&$MCVERB(&$MDGLVL)' NE '').SKIP01 ALREADY DEFINED?
&$MCVERB(&$MDGLVL) SETC 'IF'       SHOW VERB BEING EXECUTED
.SKIP01  ANOP
&NC      SETC  '&$MNC'             SET LOCAL VARIABLE
&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG
         AIF   ('&$MBLATH' NE 'PROLIFIC').FIN02
         MNOTE *,'***     LOGIC NESTING LEVEL NOW &$MDGLVL'
.FIN02   AIF   ('&$MFNAM1(1)' NE '').FIN05 GO IF F-TAG NEEDED
         AIF   ('&$MNC' EQ '').FIN08 SKIP IF B&NC NOT REQ'D
         J&NC  &X                  B AROUND DO-GROUP IF FALSE
&$MNC    SETC  ''                  FOR FUTURES
         AGO   .FIN08              EXIT
.FIN05   AIF   ('&$MC' EQ '').FIN07 SKIP IF B&C NOT REQ'D
         J&NC  &X                  B AROUND DO-GROUP IF FALSE
&$MNC    SETC  ''                  FOR FUTURES
.FIN07   ANOP
&X       SETC  '&$MFNAM1(1)'       GET 'FNAM1' FROM LEVEL 1
&$MFNAM1(&$MRECUR) SETC  ''        NULLIFY
&Y       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG
&X       EQU   &Y                  EQUATE FOR NESTED LOGIC
.FIN08   AIF   ('&$MNAME' EQ '').FIN10 GO IF NO TAG QUEUED
&$MNAME  DC    0H'0'               ESTABLISH NAME AND ADDRESS
.FIN10   ANOP
&X       SETC  '&$MPNAM1(1)'       GET 'PNAM1' FROM LEVEL 1
         AIF   ('&X' EQ '').MEND   GO IF NO 'PNAM1' FROM LEVEL 1
&$MPNAM1(1) SETC  ''        NULLIFY
&X       DC    0H'0'               ESTABLISH NAME AND ADDRESS
.MEND    ANOP                      STANDARD EXIT
&$MRECUR SETA  &$MRECUR-1          REDUCE RECURSION COUNT
         MEND
